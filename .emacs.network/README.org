:PROPERTIES:
:ID:       7bc7dff1-e0c2-4928-abc5-7ffc433a3a9a
:END:
#+TITLE:     Emacs: A Config For Network Managment
#+AUTHOR:    David Conner
#+EMAIL:     noreply@te.xel.io
#+DESCRIPTION: notes

* About

All the configuration takes place in config.el. For most of the dependencies,
you will need to have the corresponding Guix package loaded

**** TODO manual links
**** TODO guix profile list for .emacs.network
**** TODO port over minimal elisp

* Setup

** Emacs

Set up [[github:plexus/chemacs2][plexus/chemacs2]]. Plexus is one of those github repo strings worth
memorizing, like drduh and loxodo. I would install this configuration into
=~/.emacs.network=.

** Quelpa

For now, there is no =emacs-quelpa= package from Guix/

This config uses Quelpa, which is for emacs-lisp developers who want a faster
feedback loop. In this config, I'm using it for recipes to download
less-available packages like Cisco IOS mode.

** Guix Manifest

+ Tangle the manifest in this file
+ Install the the guix man

#+begin_src scheme :tangle ./emacs.network.scm
(specifications->manifest
 '(
   "git"

   ;; emacs
   "emacs-better-defaults"
   "emacs-hydra"
   "emacs-discover-my-major"

   ;; guix
   "emacs-guix"

   ;; emacs-lisp
   "emacs-dash"

   ;; lisp
   "emacs-lispy"

   ;; scheme/geiser/guile
   "emacs-geiser"
   "emacs-geiser-guile"

   ;; ansible
   "emacs-polymode-ansible"

   ;; autocomplete
   "emacs-autocomplete"

   ;; snippets
   "emacs-yasnippet"
   "emacs-yasnippet-snippets"
))
#+end_src

Then link the profile

#+begin_src shell
[[ -L $XDG_CONFIG_HOME/guix/manifests/emacs.network.scm ]] || ln -s $PWD/emacs.network.scm $XDG_CONFIG_HOME/guix/manifests/emacs.network.scm
#+end_src

#+RESULTS:

*** Loading the Manifest

If you are using this in a windows manager, then you'll need to ensure that your xsession /or whatever/ has the profile loaded wfhen you start emacs. There are a few ways to do this:

**** Windows Manager

Ensure the guix profile is loaded by your =.xsession= script and restart your
window manager. See [[file:~/.dotfiles/.xsession.eg][.xsession.eg]] for more details.

This is one abstraction boundary at which I have Guix Profiles auto-loaded, but
it's not the only dep. injection point. You shouldn't over-rely on this one --
since =guix shell= and =guix environment= obviate it and more appropriately
constructs the stripped down environment you want for whatever project you're
working on. Regardless, sometimes you need a consistent set of dependencies
available for anything loaded by your xsession or window manager shell. So, it
maybe should be here:

- if a =*.desktop= file will launch a process that needs a dep
- if you want rofi to launch it.

If you want to be able to run this profile in the console -- bc your vttys might as well be i3, right? -- then you'll want to avoid this method

**** XDG Desktop File

+ Add a =*.desktop= file and configure appropriately for your =.profile= and
  emacs. These are annoying to mess with and easily lost if not stored in VC.

**** Shepherd Service

***** TODO describe how to load a set of dependencies in on top of the shephered service before it is loaded (and when it is reloaded)

**** Emacs-Guix

The =emacs-guix= package allows you to reconcile the =GUIX_PROFILE= you have
loaded into emacs. To do this, you _may_ be able to ensure that
=(guix-set-emacs-environment &optional PROFILE)= runs in your =.emacs.d= (or
=.emacs.network= if you're following the instructions). This will happen
server-wide, so you may decide to manage multiple processes for emacs in
addition to a system-wide emacs server.

**** Guix Environment

This is the abstraction membrane to use. (I say membrane because there is no clear up or down to this tree). With a =guix shell= or =guix environment= you will be able to spawn a process, stripped down to only the guix profiles that you want to load.

* Functionality

** Guix

**** TODO complete Guix description

** Ansible

This configuration is intended mostly to get me an interface to Ansible or,
shit, at least a mode that completes my YAML keywords (something, something VS
Code).

**** TODO complete Ansible description

** Babel

Babel can be used with templating functionality, although noweb templates are do
not include funtionality that most templating systems include. Thus something more complex, like =Babel -> Jinja2= then =Shell= would be required.

**** TODO complete description

** Tramp

Configs can be deployed via SSH/Tramp. This can be done on some servers if SSH can write to the file system. Because of how

**** TODO complete Tramp description

*** Tramp with Babel

Babel can also run shell scripts on a remote server, but Ansible should be used
for this instead. Using Babel makes sense if:

+ you are working on an Ansible playbook where you don't plan on using roles or
  they are not well defined .....

** TFTP

** Cisco

This config uses =cisco-ios-mode= which i haven't fully explored yet, but should
provide a major-mode with some basic completion.

**** TODO update with more details (cisco IOS mode)

** Certificate Management

=x509-mode= provides some capability for interacting with certificates. I don't believe I'll use emacs to push certs, but instead to inspect/reflect on them.

**** TODO update with more details (x509 mode)
