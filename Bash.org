:PROPERTIES:
:ID:       db35e2a9-9fd2-41b9-9c5f-81431fdb8860
:END:
#+title: Bash Configuration
#+description:
#+startup: content
#+property: header-args        :tangle-mode (identity #o444) :mkdirp yes
#+property: header-args:sh     :tangle-mode (identity #o555) :mkdirp yes
#+property: header-args:bash   :tangle-mode (identity #o555) :mkdirp yes
#+property: header-args:scheme :tangle-mode (identity #o644) :mkdirp yes :comments link
#+options: toc:nil

* Table Of Contents :TOC_2_gh:
- [[#environment][Environment]]
  - [[#org-variables][Org Variables]]
  - [[#profile-hooks][Profile Hooks]]
  - [[#apps][Apps]]
  - [[#xdg][XDG]]
  - [[#flatpak][Flatpak]]
  - [[#steam--proton][Steam & Proton]]
  - [[#shepherd][Shepherd]]
  - [[#guix][Guix]]
  - [[#nix][Nix]]
  - [[#fcitx5][FCITX5]]
  - [[#gtk][GTK]]
  - [[#qt][QT]]
  - [[#emacs][Emacs]]
  - [[#amd-rocm][AMD ROCm]]
  - [[#podman][Podman]]
  - [[#docker][Docker]]
  - [[#kaggle][Kaggle]]
- [[#hardware][Hardware]]
- [[#languages][Languages]]
  - [[#java][Java]]
  - [[#node][Node]]
  - [[#graphql][GraphQL]]
  - [[#python][Python]]
  - [[#julia][Julia]]
- [[#profile][Profile]]
  - [[#profile-1][=.profile=]]
- [[#tools][Tools]]
  - [[#vs-codium][VS Codium]]
  - [[#screen][Screen]]
- [[#shells][Shells]]
  - [[#rc][RC]]
  - [[#bash][Bash]]
  - [[#zsh][Zsh]]
  - [[#scripts][Scripts]]
- [[#environment-1][Environment]]
  - [[#main][main]]
  - [[#devtools][devtools]]
  - [[#devdebug][devdebug]]
  - [[#netdebug][netdebug]]
  - [[#xdg-1][XDG]]
  - [[#xkb][XKB]]
  - [[#languages-1][Languages]]
- [[#tui][TUI]]
  - [[#env][Env]]
  - [[#apps-1][Apps]]

* Environment
:PROPERTIES:
:header-args+: :comments link :mkdirp yes
:END:

** Org Variables

These are intended to be a list of system-specific variables that enable some
portability: for me, across systems or networks. The idea is to containerize
this as much as possible, at least for myself, so the paths/etc work like
[[https://12factor.net/config][12Factor config vars]] or Helm values.

*** Paths

+ _DATA :: path to data mount

#+begin_quote
Note: getting this to tangle properly requires =C-c C-v C-t=.

Changing the variables above requires evaluating the block below.
#+end_quote

#+name: bash-env-bindings
| _DATA       | /data                      |
| _LANG       | /data/lang                 |
| _ECTO       | /data/ecto                 |
| _REPO       | /data/repo                 |
| _STEAM      | /flatpak/steam             |
| _AGENDA     | /flatpak/agenda            |
| _GUIX       | /gnu                       |
| _WALLPAPERS | /data/xdg/Wallpapers/anime |
| _FLATPAK    | /flatpak                   |
| DOOMDIR     | $HOME/.doom.d              |

#+name: bash-env-bindings_GEN
#+begin_src emacs-lisp :tangle no :var bindings=bash-env-bindings :results output :exports none
(mapcar #'(lambda (row)
           (princ (format "export %s=%s\n" (cl-first row) (cl-second row)))) bindings)
#+end_src

#+RESULTS: bash-env-bindings_GEN
#+begin_example
export _DATA=/data
export _LANG=/data/lang
export _ECTO=/data/ecto
export _REPO=/data/repo
export _STEAM=/flatpak/steam
export _GUIX=/gnu
export _WALLPAPERS=/data/xdg/Wallpapers/anime
export _FLATPAK=/flatpak
export DOOMDIR=$HOME/.doom.d
#+end_example

#+name: bash-env-bindings_CALL
#+call: bash-env-bindings_GEN()

#+RESULTS: bash-env-bindings_CALL
#+begin_example
export _DATA=/data
export _ECTO=/data/ecto
export _REPO=/data/repo
export _STEAM=/steam
export _GUIX=/gnu
export _WALLPAPERS=/data/xdg/Wallpapers/anime
export _FLATPAK=/flatpak
export _FLATPAK_NAME=flexpak
export DOOMDIR=$HOME/.doom.d
#+end_example

#+begin_src sh :tangle .profile :noweb yes :comments none :results none :exports none :shebang #!/bin/sh
<<bash-env-bindings_CALL()>>

# not setting gpg tty for now
#GPG_TTY="$(tty)"
#export GPG_TTY
#+end_src

#+RESULTS:

*** Create Paths

Once paths are set in your profile, you will need to do something like:

** Profile Hooks

+ =.config/sh/=
  - These scripts are not managed by =git= or =stow=
  - _before_profile.d.sh :: remaps values before =profile.d/*.sh= scripts run
  - _load_profile.d.sh :: a list of scripts loaded by =*profile=
  - _after_profile.d.sh :: remaps values after =_load_profile.d.sh= has run
+ =.config/sh/profile.d/=
  - These scripts are managed by =git= and =stow=.

**** Default Scripts

Manually copy. Stow deploys, but to no effect (no need to mess with =.stowrc= etc.)

#+begin_src sh :tangle .config/sh/_before_profile.eg.sh :shebang #!/bin/sh
# This is the default _before_profile.d.sh script
#+end_src

Note: Guix extra profiles should be loaded first in this list of
scripts. Running them with a wildcard or in any order is possible, but
it is assumed that the sequence is structured.

+ Using this approach with Guix profiles where the WM dependencies are
  loaded separeately should enable a user to choose between multiple
  window managers, as long as the login manager or display manager can
  set the list of =extra_guix_profiles= before loading the profile.
  - these scripts and the Guix Profiles would need to be tweaked to do
    so, as well as how wayland/x11-related packages are grouped.
  - In this way, a user can configure both X11 and Wayland-based window
    managers on the same system without having the package dependencies
    affect one another.

#+begin_src sh :tangle .config/sh/_load_profile.eg.sh :shebang #!/bin/sh
# This is the default _load_profile.d.sh script

__scripts=(
    "guix.sh"
    "mail.sh"
    "email.sh"
    "apps.sh"
    "xdg.sh"
    "gtk.sh"
    "qt.sh"
    "emacs.sh"
    "java.sh"
    "julia.sh"
    "graphviz.sh"
    "flatpak.sh"
)
for __script in ${__scripts[@]}; do
    [[ -f $DOTS_PROFILE_D/$__script ]] && source $DOTS_PROFILE_D/$__script || echo "couldn't load $__script"
done
unset $__script
# unset $__scripts
#+end_src

***** RC

#+begin_src sh :tangle .config/sh/_load_rc.eg.sh :shebang #!/bin/sh
# This is the default _load_rc.d.sh script

__scripts=(
    "aliases.sh"
    "functions.sh"
    "colors.sh"
    "git-prompt.sh"
    "prompt.sh"
)
for __script in ${__scripts[@]}; do
    [[ -f $DOTS_RC_D/$__script ]] && source $DOTS_RC_D/$__script || echo "couldn't load $__script"
done
unset $__script
# unset $__scripts
#+end_src

** Apps

#+begin_src sh :tangle .config/sh/profile.d/apps.sh :shebang #!/bin/sh
export MAIL=geary
export BROWSER=firefox

# TODO: update to use terminal emacsclient
export VISUAL="doomclient --"
export EDITOR="doomclient -- -nw"
export ALTERNATE_EDITOR=vim
#+end_src

** XDG

#+begin_src sh :tangle .config/sh/profile.d/xdg.sh :shebang #!/bin/sh
export WINIT_X11_SCALE_FACTOR=1
#+end_src


**** TODO collect list of pacman packages installed explicitly
** Flatpak

Install =flatseal=

Here, flatpak will be configured to use a custom installation on another
partition at =/flatpak/$USER=. To keep the flatpak app state on the same
partition, link =$HOME/.var= to =$FLATPAK_USER_VAR=.

#+begin_src sh :tangle .config/sh/profile.d/flatpak.sh :shebang #!/bin/sh
alias flatagenda="flatpak --installation=agenda"
alias flatsteam="flatpak --installation=steam"

export XDG_DATA_DIRS="/flatpak/dc/.local/share/flatpak/exports/share:${XDG_DATA_DIRS}"
# TODO move this to the guix package?
export XDG_DATA_DIRS="/flatpak/steam/.local/flatpak/exports/share:${XDG_DATA_DIRS}"
export XDG_DATA_DIRS="/flatpak/agenda/.local/flatpak/exports/share:${XDG_DATA_DIRS}"

export FLATPAK_USER_DIR=/flatpak/$(id -un)/.local/share/flatpak

# this is another variable for convenience (this var isn't used by flatpak)
export FLATPAK_USER_VAR=/flatpak/$(id -un)/.var

# Custom installations need to be configured here
# - /flatpak/steam :: $FLATPAK_CONFIG_DIR/installations.d/steam.conf
# export FLATPAK_CONFIG_DIR=/flatpak/.config/flatpak
export FLATPAK_CONFIG_DIR=/etc/flatpak

#+end_src

*** The Goal

After creating & mounting a =/flatpak= disk, syncthing can push centrally
updates to new flatpak installations to =/flatpak/syncpak123=:

+ Here they can be managed via =flatpak --installation /flatpak/syncpak123= on
  the server where flatpak is hosted
  - or, more carefully, managed from some of the local servers, assuming a consistent flatpak environment on the syncthing clients.
  - these clients (or the client disk permissions) should set some of the
    syncthing permissions to read only.
  - on the client, =XDG_CONFIG_DIR= is always read after =XDG_CONFIG_HOME=, so
    for any app, its configs can be transparently overridden, without affecting the synced flatpak installations.
+ Then the custom flatpak installations can be linked into the local system via
  =stow=, where a few modifications to =XDG= vars will pick them up.

This method has not been tested yet. However, since they are plain binaries, then they should be syncable.

** Steam & Proton

+ [[See ][PC Gaming Wiki]] describes Steam Library & Game Data locations

#+begin_src sh :tangle .config/sh/profile.d/steam.sh :shebang #!/bin/sh
export STEAM_DIR=$_STEAM/.var/app/com.valvesoftware.Steam/.steam
export FLATPAK_STEAM_VAR=/flatpak/steam/.var

# log with PROTON_LOG=1
export PROTON_LOG_DIR=$_STEAM/log/proton
export PROTON_CRASH_REPORT_DIR=$_STEAM/log/proton-crash

alias run_steam="flatpak --installation=steam run com.valvesoftware.Steam"
#+end_src

Run with =FLATPAK_CONFIG_DIR=/etc/flatpak flatpak --installation=steam run com.valvesoftware.Steam=

Or simply =flatpak --installation=steam run com.valvesoftware.Steam=

*** Setup

+ Add =steam.sh= to =~/.config/sh/_load_profile.d.sh=

#+begin_src sh :tangle no :eval no
mkdir -p $_STEAM $FLATPAK_STEAM_VAR/com.valvesoftware.Steam

# because flatpak steam will try to symlink /flatpak/dc/.var/com.valvesoftware.Steam/.var to ~/.var (which is very confusing)
ln -s /flatpak/steam/.var/app/com.valvesoftware.Steam /flatpak/dc/.var/com.valvesoftware.Steam

# ensure that FLATPAK_CONFIG_DIR is defined and that the steam flatpak install exists
flatpak --installations

flatpak --installation=steam remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
flatpak --installation=steam remote-add --if-not-exists flathub-beta https://flathub.org/beta-repo/flathub-beta.flatpakrepo

flatpak --installation=steam install flathub com.valvesoftware.Steam
flatpak --installation=steam install flathub com.valvesoftware.Steam.CompatibilityTool.Proton
#+end_src

**** Issues

+ After invoking for the first time, if this link shows up, remove it
  - =rm /flatpak/steam/.var/app/com.valvesoftware.Steam/.var=
+ Flatpak steam will ignore =STEAM_DIR= anyways...
  - it will put the steam library within the steam install under
    =/flatpak/steam/.var/app/com.valvesoftware.Steam/.var=


***** TODO consider creating ./flatpak/installations.d/steam.conf


** Shepherd

Guix Home is definitely the way to manage services for your desktop. However, if
you simply use Guix Home, it's very likely you'll never use multiple shepherd
processes, which is yes complicated but also one of the advantages IMO.

**** TODO finish Misc shepherd utils

#+begin_src sh :tangle .config/sh/profile.d/shepherd-util.sh :shebang #!/bin/sh
sherpid() {
    #local log=
    #local cfg=
    local pidfile=
    local sock=
    #local rflag=

    #--long-options pidfile::,sock::,logfile:,config:,r:
    echo "parsing"
    while getopts "p::s::l:c:r:" opt; do
        case "$opt" in
            p) pidfile=$opt;;
            s) sock=$opt;;
            l) log=$opt;;
            c) cfg=$opt;;
            r) rflag=$opt;;
            ?) usage;;
        esac

        echo $pidfile $sock $log $cfg $rflag
    done

}
#+end_src

** Guix

=GUIX_AUTOLOAD_PROFILES=(desktop i3)= should be set in the script run
by the login/display manager, but not exported.

#+begin_src sh :tangle .config/sh/profile.d/guix.sh :shebang #!/bin/sh
alias guix-all-profiles='find /gnu/store -maxdepth 1 -type d -name "*profile" -exec ls -al \{\} +'
alias guix-main="$HOME/.config/guix/current/bin/guix"

# TODO fix for non-guix-systems
# GUIX_PROFILE="$HOME/.guix-profile"
# . "$GUIX_PROFILE/etc/profile"

export GUIX_LOCPATH=$HOME/.guix-profile/lib/locale

# -c cores -m jobs
export GUIX_BUILD_OPTIONS="-c$NCPU"

export GUIX_DEVTOOLS=$GUIX_EXTRA/devtools/devtools
export GUIX_DEVDEBUG=$GUIX_EXTRA/devdebug/devdebug
export GUIX_EXTRA=$HOME/.guix-extra-profiles

#+end_src

#+begin_src sh :tangle .config/sh/profile.d/guix-profiles.sh
# GUIX_AUTOLOAD_PROFILES=(desktop i3)
if [[ -z $GUIX_AUTOLOAD_PROFILES ]]; then
    GUIX_AUTOLOAD_PROFILES=(i3 desktop fonts browsers xkb pipewire \
                               mon devtools academic office cad kicad \
                               pythondev k8s)
fi

for i in ${GUIX_AUTOLOAD_PROFILES[@]}; do
  echo $i
  profile=$GUIX_EXTRA/$i/$i
  if [ -f "$profile"/etc/profile ]; then
    GUIX_PROFILE="$profile"
    . "$GUIX_PROFILE"/etc/profile
  fi
  unset $profile
done
#+end_src


Misc guix utils

#+begin_src sh :tangle .config/sh/profile.d/guix-utils.sh :shebang #!/bin/sh

#+end_src

Guix aliases

*** On Arch
**** Load Guile for Emacs-Guix

Emacs guix needs a consistent guile environment (See [[https://github.com/alezost/guix.el#important-note-for-non-guix-system-users][this note]]).

+ =GUILE_LOAD_PATH= should be defined properly and should include guix modules.
+ So, =guix package -i guix guile= to install guix and guile into the user
  profile but reload the current profile afterwards.
+ And finally, =emacs-guix= should work as expected on a foreign distro
  - also, running =doom purge= when moving emacs packages between guix and
    doom's straight is essential. any shared dependencies will likely be brought
    in from doom (not guix)
  - in other words ... you kinda must pick a team (or micromanage your
    =EMACSLOADPATH=)

#+begin_src sh :tangle .config/sh/profile.d/guile-arch.sh :shebang #!/bin/bash
export GUIX_EXTRA=$HOME/.guix-extra-profiles
# source "$HOME/.guix-profile/etc/profile"
# source "$HOME/.config/guix/current/etc/profile"
# export GUILE_LOAD_PATH=$HOME/.guix-profile/share/guile/site/3.0:$GUILE_LOAD_PATH
# export GUILE_LOAD_COMPILED_PATH=$HOME/.guix-profile/lib/guile/3.0/site-ccache:$HOME/.guix-profile/share/guile/site/3.0:$GUILE_LOAD_COMPILED_PATH
#+end_src

***** Note on =/etc/profile.d/guix.sh= from AUR

AUR guix-install sets this up in /etc/profile.d/guix.sh.

#+begin_example sh :eval no
if [ -z "$GUIX_LOCPATH" ]; then
    GUIX_PROFILE=$HOME/.guix-profile
    source "$GUIX_PROFILE/etc/profile"
    export GUIX_LOCPATH=$HOME/.guix-profile/lib/locale
fi
#+end_example

+ It will load =_GUIX_PROFILE= first (the current profile), then load
  =.guix-profile/etc/profile=, if it exists.
+ If you haven't installed anything that requires setting =PATH=, no path
  modifications will be visible (confusing!)

**** Load Guix Profiles

#+begin_src sh :tangle .config/sh/profile.d/guix-arch-support.sh :shebang #!/bin/bash
guix_arch_load() {
    local profiles=""

    while [ "$1" != "" ]; do
        case $1 in
            -*|--*=) # unsupported flags
            echo "Error: Unsupported flags $1" >&2
            return 1
            ;;
            ,*)
                profiles="$profiles $1"
                shift
                ;;
        esac
    done

    if [ -z "$profiles" ]; then
        # NOTE: this glob behaves strangely when $GUIX_EXTRA is empty
        # profiles="$GUIX_EXTRA/*";
        echo "Error: no profiles specified"
    fi

    local profilePath=""
    for p in $profiles; do
        profile=$(basename $p)
        echo $profile
        profilePath=$GUIX_EXTRA/$profile
        if [ -f "$profilePath/$profile/etc/profile" ]; then
            GUIX_PROFILE="$profilePath/$profile"
            source "$GUIX_PROFILE/etc/profile"
        fi
    done

    return 0
}

export -f guix_arch_load

#+end_src

The default is -c0, which uses as many cores as possible for each build agent,
so no need to set =-c= in $GUIX_BUILD_OPTIONS

#+begin_src sh :tangle .config/sh/profile.d/guix-arch.sh :shebang #!/bin/bash
# export GUIX_BUILD_OPTIONS="-c6"

# never again, wxPython ... never again
GUIX_AUTOLOAD_PROFILES=(arch-pwsafe academic arch-devtools nyxt k8s)
if [ -z "$GUIX_ARCH_LOADED" ]; then
    guix_arch_load ${GUIX_AUTOLOAD_PROFILES[@]}
    export GUIX_ARCH_LOADED=${GUIX_AUTOLOAD_PROFILES[@]}
fi

GUIX_PROFILE="$HOME/.config/guix/current"
source "$GUIX_PROFILE/etc/profile"
#+end_src

Add to =~/.config/sh/_load_profile.d.sh= _in this order_

+ guile-arch.sh
+ guix-arch-support.sh
+ guix-arch.sh

** Nix

It seems I'm more likely to encounter this on programming projects/teams.

#+begin_src sh :tangle .config/sh/profile.d/nix-arch.sh :shebang #!/bin/bash
# add your main nix-profile to paths
export PATH=$HOME/.nix-profile/bin:$PATH
export XDG_DATA_DIRS=$HOME/.nix-profile/share:$XDG_DATA_DIRS

# TODO add potential for other Nix profiles
#+end_src

Then add =nix-arch.sh= to =~/.config/sh/profile.d= preferably before =guix-arch.sh=.

After setup, happily build the free [[https://github.com/hmemcpy/milewski-ctfp-pdf][Category Theory For Programmers PDF]]. This
requires adding the following.

#+begin_src nix :tangle .config/nix/nix.conf :mkdirp yes :comments none
extra-experimental-features = nix-command flakes
#+end_src

*** On Arch

Install Nix and setup the groups. Configure =~/.config/nix/nix.conf= if necessary.

#+begin_example shell
yay -Syu nix

# to allow user access to the nix build daemon
sudo usermod -G nix-build

echo "max-jobs = auto" | sudo tee -a /etc/nix/nix.conf
#+end_example

Ensure that the =nix-ademon= service is running or just enable it.

#+begin_example shell
# to make fedora a tolerable daily driver. run with sudo to add channel to root
nix-channel --add https://nixos.org/channels/nixpkgs-unstable

# requires sudo to create /nix/store
nix-channel --update
#+end_example

Now nix should build and =direnv allow= should run flakes right.

** FCITX5

According to =fcitx5-diagnose= these need to be set to =fcitx= NOT =fcitx5=.

#+begin_src sh :tangle .config/sh/profile.d/fcitx5.sh :shebang #!/bin/sh
# export QT_IM_MODULE=fcitx
# export GTK_IM_MODULE=fcitx
# export SDL_IM_MODULE=fcitx
# export XMODIFIERS="@im=fcitx"
#+end_src

If fcitx5 is being loaded by a guix profile that doesn't update =XDG_DATA_DIRS=, then that variable needs to be updated as well

#+begin_src sh :tangle .config/sh/profile.d/fcitx5-guix.sh :shebang #!/bin/sh
export FCITX_ADDON_DIRS=$GUIX_EXTRA/fcitx5/fcitx5/lib:$FCITX_ADDON_DIRS
#export FCITX_CONFIG_HOME=
#export FCITX_DATA_DIRS=
#export XDG_DATA_DIRS=$GUIX_EXTRA/fcitx5/fcitx5/share:$XDG_DATA_DIRS
#+end_src

** GTK

#+begin_src sh :tangle .config/sh/profile.d/gtk.sh :shebang #!/bin/sh
# GTK
export GTK2_RC_FILES="$HOME/.gtkrc-2.0"

#export GDK_BACKEND=wayland             # this can prevent programs from starting (e.g. chromium and electron apps). therefore, this should be set per app instead of globally.
#+end_src

** QT

#+begin_src sh :tangle .config/sh/profile.d/qt.sh :shebang #!/bin/sh

# Qt
#export QT_QPA_PLATFORMTHEME="qt5ct"
#export QT_QPA_PLATFORM=wayland
#export QT_WAYLAND_FORCE_DPI=physical
#export QT_WAYLAND_DISABLE_WINDOWDECORATION=1

alias qutebrowser='QTWEBENGINE_CHROMIUM_FLAGS=\"--disable-seccomp-filter-sandbox\" qutebrowser'
alias anki='QTWEBENGINE_CHROMIUM_FLAGS=\"--disable-seccomp-filter-sandbox\" anki'

#+end_src

**** TODO remove aliases aboves after fix for [[https://issues.guix.gnu.org/52993][Guix #52993]] is fixed

** Emacs

#+begin_src sh :tangle .config/sh/profile.d/emacs.sh :shebang #!/bin/sh

export ORG_DIRECTORY=/data/org
#export ORG_AGENDA_ROOT=
#export ORG_ROAM_ROOT

# TODO this error handling is not working
# cp: cannot stat '"/home/dc/.emacs.g/emacs-g.scm"': No such file or directory
gmacsupdate() {
  local gmacsprofile=$(emacsclient -e '(expand-file-name "emacs-g.scm" dc/emacs-d)' -a "Couldn't fetch 'user-emacs-directory from emacs server")
  local status=$?
  [[ $status -ne 0 ]] || [[ -e $gmacsprofile ]] && return 1;
  cp $gmacsprofile $XDG_CONFIG_HOME/guix/manifests/
  echo updating emacs-g profile
  update-profiles emacs-g

  return 0
}

#+end_src

** AMD ROCm


Ensure user is added to =video= and =render= groups. Probably just use the ROCm
docker images.

** Podman

Ensure that Podman stores images on the correct mount.

#+begin_example conf :tangle .config/containers/storage.conf
[storage]

driver = "overlay"
rootless_storage_path = "/storage/location"
#+end_example

Rootful images must be stored in a root-owned folder directory with correct
permissions AFAIK.

** Docker

Ensure that Docker is configured to store images on the correct mount.

#+begin_example json :tangle /etc/docker/daemon.json
{
  "data-root": "/storage/location"
}
#+end_example

The docker systemd services must have been run at least once for many of its
paths to exist.

Test with =docker pull docker.io/netbootxyz/netbootxyz=

** Kaggle

#+begin_src sh :tangle .config/sh/kaggle.sh
kacomp() {
    if [ $# = 0 ]; then
        echo Requires search parameter
        return 1
    else
        kaggle c list | grep $1 | cut -f1 -d' ' | rev | cut -f-1 -d'/' | rev
    fi
}

# doesn't work at the moment, but the discussion tabs sure take up 150 MB of RAM
# google owns kaggle and wants you to use TF Lite, but can't quite seem to
# return the favor
#
# (no offense, Kaggle, but i fucking hate javascript for the same reason that
#  google might want you to use TF Lite ... it's funny how that works)
kacomp_set() {
    kaggle_comp="$(kacomp $1)"
    [[ -z $kaggle_comp ]] && return 1
    kaggle config set -n competition -v $kaggle_comp
}
#+end_src


* Hardware

On Guix and Arch

#+begin_src sh :tangle bin/ncpu-threads :shebang #!/bin/sh
ls -d /sys/devices/system/cpu/cpu* | grep -E "/cpu[0-9]+$" | wc -l
#+end_src

On Arch:

#+begin_src sh :tangle bin/ncpu-threads-arch :shebang #!/bin/sh
ls -al /sys/class/cpuid/cpu* | wc -l
#+end_src

Typically, I'd only like to commit half threads to anything

#+begin_src sh :tangle .profile :shebang #!/bin/sh
if [[ ! -d "$HOME/bin" ]]; then
    echo "Move ~/bin to ~/bin !!"
fi

export PATH=$HOME/.local/bin:$HOME/bin:$PATH
export DISTRO="$(grep -e '^ID=' /etc/os-release | sed -e 's/^ID=//g')"

# can't add functions to .bash_profile: only .bashrc
export NTHREADS="$(ncpu-threads)"
if [[ -n "$NTHREADS" ]]; then
    NCPU="$((NTHREADS / 2))"
else
    NCPU="4"
fi
export NCPU
#+end_src

* Languages
:PROPERTIES:
:header-args+: :comments link :mkdirp yes
:END:

#+begin_src sh :tangle no

#+end_src

** Java

#+begin_src sh :tangle .config/sh/profile.d/java.sh :shebang #!/bin/sh
export _JAVA_AWT_WM_NONREPARENTING=1

# This sets Java Swing UI -> GTK
#export _JAVA_OPTIONS="-Dawt.useSystemAAFontSettings=on -Dswing.aatext=true -Dswing.defaultlaf=com.sun.java.swing.plaf.gtk.GTKLookAndFeel -Dswing.crossplatformlaf=com.sun.java.swing.plaf.gtk.GTKLookAndFeel $_JAVA_OPTIONS"

# multiple java versions
# https://docs.doomemacs.org/v21.12/modules/lang/java/#/prerequisites/multiple-java-versions

# TODO: set differently for arch/guix
#export JAVA_HOME=/usr/local/jdk-11.0.2
#export PATH=$PATH:$JAVA_HOME/bin

export ECLIPSE_HOME=${_LANG}/.eclipse/eclipse
#+end_src

*** Eclipse

For Guix, eclipse should basically just require an OpenJDK

#+begin_src sh :tangle bin/eclipse.sh :shebang #!/bin/sh
export ECLIPSE_HOME=${_LANG}/.eclipse/eclipse

# TODO: provide JAVA_PATH/etc and exec eclipse 
#+end_src

** Node

Install =nodejs= profile.

*** NVM

This is an old config

#+begin_src sh :tangle .config/sh/profile.d/node-arch.sh :shebang #!/bin/sh
[[ -f /usr/share/nvm/init-nvm.sh ]] && source /usr/share/nvm/init-nvm.sh
#+end_src

*** On Arch

#+begin_src sh :tangle .config/sh/profile.d/node-arch.sh :shebang #!/bin/sh
# npm install -g # bins go here
export NPM_CONFIG_PREFIX=$HOME/.npm-global
export PATH=$NPM_CONFIG_PREFIX/bin:$PATH
# export NPM_CONFIG_USERCONFIG=$HOME/.npmrc # default
# export NPM_CONFIG_GLOBALCONFIG=/usr/lib/node_modules/npm/npmrc # but it's not listed under `npm config ls -l`
#+end_src

*** On Guix

#+begin_src sh :tangle .config/sh/profile.d/node-guix.sh :shebang #!/bin/sh
# npm install -g # bins go here
export NPM_CONFIG_PREFIX=$HOME/.npm-global
export PATH=$NPM_CONFIG_PREFIX/bin:$PATH
# export NPM_CONFIG_USERCONFIG=$HOME/.npmrc # default
# export NPM_CONFIG_GLOBALCONFIG=$NODE_PROFILE/lib/node_modules/npm/npmrc # default
#+end_src

** GraphQL

On Guix, ensure =nodejs= profile is installed.

#+begin_src :eval no
npm install -g graphql-language-service-cli
#+end_src

Graphql-language-service-cli depends on:

+ graphql-language-service
+ graphql-language-service-server

Other tools include:

+ graphiql
+ codemirror-graphql
+ graphiql

*** GraphQL Project Setup

On Guix Systems, add the =nodejs= profile to the project or ensure that it's in
=$PATH=. Most actual projects will have their own =manifest.scm= anyways. This
will be a separate node build, but its =npm install -g= binaries will still go
in =.node_modules=

#+begin_src sh
#or use_guix_manifest -m $XDG_CONFIG_HOME/guix/manifests/nodejs.scm
use_guix_profile -m $GUIX_EXTRA/nodejs/nodejs
#+end_src

***** TODO finalize on =use_guixs=
***** TODO how to designate the default graphql schema file for the above?

** Python

This should end up in =$HOME= to fix an issue where =jupyter.el= uses =$HOME=
as its default directory. This main python should have =pip= set up with the
=jupyter-lab= environment, which can load kernels can be built from other
=venvs= ... (this might conflict with other information on jupyter herein)

#+begin_src sh :tangle .python-version
3.12.1
#+end_src

*** Python on Arch

**** Pyenv

Ensure pyenv is installed with =yay -Syu pyenv= and add this to
=.config/sh/_load_profile.d.sh=. This should be loaded after all the guix
profiles, in case one contains a python.

#+begin_src sh :tangle .config/sh/profile.d/python-pyenv.sh :shebang #!/bin/sh
export PYENV_POETRY_VENV=poetry
export PYENV_ROOT="$_LANG/.pyenv"
command -v pyenv >/dev/null || export PATH="$PYENV_ROOT/bin:$PATH"
eval "$(pyenv init -)"
source "${PYENV_ROOT}/completions/pyenv.bash"
#+end_src

+ Install new pythons with =pyenv install 3.11.3= and see below for optimizations.
+ List versions with =pyenv install -l=
+ Switch with =pyenv (shell|local|global) $python_version=. This is currently
  not working, since I only have =eval $(pyenv init -)= sourced in =.profile=,
  which forgets the =pyenv()= function. To get the shell integration to work, it
  needs to be added to =.bashrc=.

See direnv integration below.

****** TODO evaluate whether I should add =pyenv= to both =.profile= and =.bashrc=

***** Switching

Caveat scriptor: running =pyenv local $pyversion= will create a
=$PWD/.python-version= file. Use =pyenv shell $pyversion= instead.

***** Custom Pyenv builds

See pyenv's =python-build= plugin to customize the build

+ [[https://github.com/pyenv/pyenv/tree/master/plugins/python-build#special-environment-variables][Environment vars]] for pyenv's python-build plugin.
+ The spec for [[https://github.com/pyenv/pyenv/blob/master/plugins/python-build/share/python-build/3.11.3][Python 3.11.3]] is in =./plugins/python-build/share/3.11.3/=
+ The installations will source functions in
  =./plugins/python-build/bin/python-build=, including =install_package= which
  fetches source for python.
+ It also fetches packages like =readline= or =openssl-1.1.1s= if your Mac's is
  broken. I guess OpenSSL3 is [[https://peps.python.org/pep-0644/][taking its sweet time]], but convenience comes at a
  cost -- mostly, you'll run into issues with the [[https://cryptography.io/en/latest/installation/#building-cryptography-on-macos][cryptography package]].

****** Optimizations

To build with optimizations:

#+begin_src sh
PYTHON_CONFIGURE_OPTS='--enable-optimizations --with-lto' PYTHON_CFLAGS='-march=native -mtune=native'
#+end_src

To build in parallel (doesn't seem to help)

#+begin_src sh
MAKE_OPTS="-j14" PYTHON_MAKE_OPTS="-j14"
#+end_src

Full command

#+begin_src sh :tangle bin/pynv-install-py
[[ -z "$1" ]] && echo "Requires semantic version" && exit 1;

version=$1

mjobs=$((NTHREADS - 2))

env PYTHON_CONFIGURE_OPTS='--enable-optimizations --with-lto' \
    PYTHON_CFLAGS='-march=native -mtune=native' \
    PYTHON_MAKE_OPTS="-j$mjobs" \
    MAKE_OPTS="-j$mjobs" \
    pyenv install $version 2>&1 > ~/src/log/python-build-$version.log
#+end_src

Then =pip install --upgrade pip= and set up =jupyter-lab= from within that new
python's main env.

#+begin_example sh
pip install --upgrade
pip install jupyter-lab # etc...
#+end_example

**** Poetry

Basically poetry projects (& their venv's) will need to be handled
separately. From what I understand, each python that is installed will need to
have its own =poetry= installed. The =virtualenvs.prefer-active-python= will
accomplish that, as long as poetry runs after =direnv= sets the =pyenv= and as
long as there isn't an active =venv= for that =pyenv= in the shell -- these have
a separate =pip=.

There is also [[https://github.com/tjquillan/poetry-plugin-pyenv][tjquillan/poetry-plugin-pyenv]].

***** Keyring

In KDE, unless there's a reason for pip to cache in keyring, then maybe
disable it: =`pyenv which python3` -m keyring --disable=

See [[https://stackoverflow.com/a/68760190]]

***** Poetry Config

See [[id:][configuration]] docs. The shared poetry configuration, which will use the
=poetry= shim in the python selected by =pyenv= selects. In any python project,
the version should be set by =.python-version=.

#+begin_src conf-toml :tangle .config/pypoetry/config.toml
[virtualenvs]
prefer-active-python = true
#+end_src

****** Defaults

Without any other config, once =poetry= is installed for =$pyversion=, then
=poetry config --list= should show:

#+begin_src conf
cache-dir = "$HOME/.cache/pypoetry"
experimental.new-installer = true
experimental.system-git-client = false
installer.max-workers = null
installer.modern-installation = true
installer.no-binary = null
installer.parallel = true
virtualenvs.create = true
virtualenvs.in-project = null
virtualenvs.options.always-copy = false
virtualenvs.options.no-pip = false
virtualenvs.options.no-setuptools = false
virtualenvs.options.system-site-packages = false
virtualenvs.path = "{cache-dir}/virtualenvs"  # $HOME/.cache/pypoetry/virtualenvs
virtualenvs.prefer-active-python = false
virtualenvs.prompt = "{project_name}-py{python_version}"
#+end_src

**** Python Direnv

This method is compatible with the others, so a project on one laptop with
=pyenv= and lacking the =pyenv-virtualenv= plugin will simply need to change
=.envrc=. Both should be able to use =layout python=.

*Generally*

+ Use =layout poetry= where practical/possible (... test?)
+ Use the =pyenv-virtualenv= for one-off environments or things to don't fit
  neatly into dependency specs

***** Direnv: [[https://github.com/direnv/direnv/wiki/Python#venv-stdlib-module][layout python3]]

Specify with =layout python3=, which uses venv stdlib module

This directive causes a virtualenv to be created at
=$PWD/.direnv/python-$python_version=.

#+begin_quote
Commenting out the =layout= will cause this directory to appear.
#+end_quote

***** Direnv: [[https://github.com/direnv/direnv/wiki/Python#poetry][layout pyenv]]

Requires [[github:pyenv/pyenv][pyenv/pyenv]]

Specify with =layout pyenv $python_version=

This directive still installs python packages in the virtualenv at
=$PWD/.direnv/python-$python_version=.

#+begin_quote
Commenting out the =${pyenv}= will cause this directory to appear.
#+end_quote

***** Direnv: =layout pyenv $python_version=

Requires [[github:pyenv/pyenv-virtualenv][pyenv-virtualenv]]

Specify with =layout virtualenv= and =layout activate= in a project's
=.envrc=. This template can easily be changed/managed locally for more granular
specification, but allows for some defaults

#+begin_src sh :tangle .config/direnv/eg/pyenv :tangle-mode (identity #o644)
# -*- mode: sh; -*-
[[ -f ".python-version" ]] && pyversion=$(head .python-version) || pyversion="3.10.11"
[[ -f ".python-virtualenv" ]] && pvenv=$(head .python-virtualenv) || pvenv=$(basename $PWD)

#use python ${pyversion}

# Create the virtualenv if not yet done (just depend on .python-version for this)
layout virtualenv ${pyversion} ${pvenv}
layout activate ${pvenv}-${pyversion}
#+end_src

This method requires adding the following to =.config/direnv/direnvrc=

#+begin_src sh :tangle .config/direnv/direnvrc :shebang #!/bin/sh
# use a certain pyenv version
use_python() {
    if [ -n "$(which pyenv)" ]; then
        local pyversion=$1
        pyenv local ${pyversion}
    fi
}

layout_virtualenv() {
    local pyversion=$1
    local pvenv=$2
    if [ -n "$(which pyenv virtualenv)" ]; then
        pyenv virtualenv --force --quiet ${pyversion} ${pvenv}-${pyversion}
    fi
    pyenv local --unset
}

layout_activate() {
    if [ -n "$(which pyenv)" ]; then
        source $(pyenv root)/versions/$1/bin/activate
    fi
}
#+end_src

Adding this to =.direnvrc= will cause new environments to be created in:

=$(pyenv root)/versions/$python_version/$virtualenv_name=.

These environments can be shared ... potentially leaded to some isolated
dependency/build concerns (e.g. tensorflow with/out GPU or installing a set of
dependencies not satisfied by what's already installed). It doesn't share
installation roots.

However, since =direnv= use of functions named =use_.*= is special, I'm not
quite sure how well these methods mix.

***** Direnv: [[https://github.com/direnv/direnv/wiki/Python#poetry][layout poetry]]

Requires [[github:python-poetry/poetry][python-poetry/poetry]] to be [[https://python-poetry.org/docs/#installing-with-the-official-installer][installed]]. This method is helpful when
working on a python lib, since it isolates the installation into =.venv=.

#+begin_src sh :tangle .config/direnv/eg/poetry :tangle-mode (identity #o644)
layout poetry

local venvname=$(echo "$VIRTUAL_ENV" | rev | cut -d'/' -f2- | rev)
PS_INFO="${PS_INFO} <${GREEN}$(pyenv version-name) ${WHITE}poetry: ${YELLOW}${venvname}${WHITE}> ::${RESTORE}"

# TODO setting the prompt doesn't quite work
export PS1="${PS_INFO}\n${PS_PROMPT}"
#+end_src

Just use the =.venv= environment. There should not be a =.python-virtualenv=
file. The =poetry.toml= may look something like:

#+begin_example conf-toml
[virtualenvs]
#create = false
in-project = true
#+end_example

Specify with =layout poetry=

#+begin_src sh :tangle .config/direnv/direnvrc :shebang #!/bin/sh
# TODO: either use_poetry() or....
# ensure pyenv version

layout_poetry() {
    PYPROJECT_TOML="${PYPROJECT_TOML:-pyproject.toml}"
    if [[ ! -f "$PYPROJECT_TOML" ]]; then
        log_status "No pyproject.toml found. Executing \`poetry init\` to create a \`$PYPROJECT_TOML\` first."
        poetry init
    fi

    if [[ -d ".venv" ]]; then
        log_status "Setting VIRTUAL_ENV=\$(pwd)/.venv"
        VIRTUAL_ENV="$(pwd)/.venv"
    else
        log_status "Setting VIRTUAL_ENV=\$(poetry env info --path 2)/.venv"
        VIRTUAL_ENV=$(poetry env info --path 2>/dev/null ; true)
    fi

    if [[ -z $VIRTUAL_ENV || ! -d $VIRTUAL_ENV ]]; then
        log_status "No virtual environment exists. Executing \`poetry install\` to create one."
        poetry install
        VIRTUAL_ENV=$(poetry env info --path)
    fi

    PATH_add "$VIRTUAL_ENV/bin"
    export POETRY_ACTIVE=1
    export VIRTUAL_ENV
}

#layout_vpoetry() {
#    echo foo
#}
#+end_src

*Compatibility with pyenv:* Poetry will use the python it encounters first in
your path if =virtualenvs.prefer-active-python= is set, so it should use the one
that =pyenv= hands it via its shims.

+ It will install this virtualenv into =${cache-dir}= which is
  =$HOME/.cache/pypoetry/virtualenvs=
+ See [[https://python-poetry.org/docs/configuration#configuration][Configuration]] and [[https://python-poetry.org/docs/managing-environments/][Managing Environments]].

***** TODO direnv show branch name

This won't work since the =.envrc= is only evaluated once (which is what I'd
prefer vs. a highly dynamic shell)

#+begin_src sh
if [ -d ".git" ]; then
    local gbranch="$(git branch --show-current)"
    local ghash="$(git log -n1 --pretty=%H)"

    PS_INFO="${PS_INFO} ::"
fi
#+end_src


*** Python on Guix

I'm just going to use the Guix python packages and setup pip to support
virtualenvs.

#+begin_src scheme :tangle .config/guix/manifests/pythondev.scm
(specifications->manifest
 '(
   "python"
   "python-pip"

   "docker-compose"
   ))
#+end_src

The description of Direnv's =layout python= directive is a bit confusing. I
didn't understand that I could simply set the virtualenv with the following:

#+begin_example shell
export VIRTUALENV=~/.my-persistent-venvs/jupyter-with-tensorflow-venv
layout python
#+end_example

**** Just going to use docker when I need to

** Julia

Julia [[https://docs.julialang.org/en/v1/manual/environment-variables/][Environment Variables]]

#+begin_src sh :tangle .config/sh/profile.d/julia.sh :shebang #!/bin/sh
export JULIA_SHELL=/bin/sh
export JULIA_EDITOR='emacsclient -nw'

export JULIA_DEPOT_PATH="$_LANG/.julia:"
export JULIA_LOAD_PATH="$_LANG/.julia:"
#+end_src

This configuration is intended to be used on archlinux.

#+begin_src sh :tangle .config/direnv/direnvrc :shebang #!/bin/sh

# The guix package for julia creates ./bin/julia,
# which is a wrapper for ./bin/.julia-real
use_julia_system() {
    # These auto-expand empty entries, but =JULIA_LOAD_PATH= can't be set if empty.
    export JULIA_DEPOT_PATH="$_LANG/.julia:"
    export JULIA_LOAD_PATH="$_LANG/.julia:"
    export JULIA_PATH="$_LANG/julia"
    export JULIA_VERSION="1.7.3"

    export JULIA_BIN="$JULIA_PATH/bin/julia-$JULIA_VERSION/bin/julia"
    export JULIA_LIB="$JULIA_PATH/bin/julia-$JULIA_VERSION/lib/julia"

    PATH_add "$JULIA_PATH/bin"

    alias pluto='julia --project=nb --threads=auto -e "using Pluto; Pluto.run(port=4321)"'
}
#+end_src

Julia .envrc template:

#+begin_src sh :tangle .config/direnv/.julia.envrc
use julia_system
#watch_file /home/dc/.config/direnv/direnvrc
#+end_src

* Profile
:PROPERTIES:
:header-args+: :comments link :mkdirp yes
:END:

** =.profile=

If =.bash_profile= does not exist, =.profile= will be sourced instead. When bash
is invoked as =sh=, then it will source =.profile= anyways.

*** Before Profile.d

#+begin_src sh :tangle .profile :shebang #!/bin/sh
export DOTS_CFG_SHELL=$XDG_CONFIG_HOME/sh
export DOTS_PROFILE_D=$DOTS_CFG_SHELL/profile.d

[[ -f $DOTS_CFG_SHELL/icons.sh ]] && source $DOTS_CFG_SHELL/icons.sh

# Profile
[[ -f $DOTS_CFG_SHELL/_before_profile.d.sh ]] && source $DOTS_CFG_SHELL/_before_profile.d.sh
[[ -f $DOTS_CFG_SHELL/_load_profile.d.sh ]] && source $DOTS_CFG_SHELL/_load_profile.d.sh
#+end_src

#+begin_src sh :tangle .profile :shebang #!/bin/sh
export MOZ_DBUS_REMOTE=1                # fixes firefox is already running, but is not responding
# disables accessibility
export NO_AT_BRIDGE=1
#+end_src

*** After Profile.d

#+begin_src sh :tangle .profile :shebang #!/bin/sh
[[ -f $DOTS_CFG_SHELL/_after_profile.d.sh ]] && source $DOTS_CFG_SHELL/_after_profile.d.sh
#+end_src

*** Source =.bashrc=

Try to source =.bashrc=. If the shell is non-interactive, =.bashrc= will return

#+begin_src sh :tangle .profile :shebang #!/bin/sh
[[ -f $HOME/.bashrc ]] && source $HOME/.bashrc
#+end_src

* Tools
:PROPERTIES:
:header-args+: :comments link :mkdirp yes
:END:

** VS Codium

Note the flatpak configuration instructions in [[github:flathub/com.vscodium.codium][flathub/com.vscodium.codium]]

The =vscodium= flatpak comes with a standard development environment and has a
python bundled inside.

*** Configuration

+ User config is in =./User/settings.json=. You could symlink or sync online.
+ Workspace configurations are in =./User/workspacestorage=

*** Environment

**** On Guix

If =~/.pyenv= exists, VSCode will think you have =pyenv=.

***** Shell Profile

Ensure =terminal.integrated.profiles.linux= includes a profile that injects
=GUIX_AUTOLOAD_PROFILES=. The set of profiles should include one that contains
=direnv= and other tools.

On Guix System, VSCode forks from a login profile -- but from before the
=.xsession= script runs. Set up a terminal profile like the following to run
your =.profile= logic like it's a login shell, which will also load =.bashrc=.
This sources the =~/.config/sh/profile.d/guix.sh= script, which should load a
custom set of profiles.

#+begin_src json

"bash": {
  "path": "bash",
  "icon": "terminal-bash",
  "env": {
    "GUIX_AUTOLOAD_PROFILES": "(desktop fonts mon devtools academic pythondev)"
  },
  "args": ["-l"]
}
#+end_src

The value for =GUIX_AUTOLOAD_PROFILES= gets interpreted as an array.

**** Direnv in VSCode

The [[github:direnv/direnv-vscode][direnv/direnv-vscode]] plugin only works for:

+ integrated terminals
+ custom tasks of type =shell=
+ environment variable substitutions like =${env:VAR}=

This really doesn't jive with how I'm loading environments, unless I'm working
in a Docker container.

+ It's not really clear how extensions run commands -- though I just don't
  know what VSCode does. There are logs somewhere. This probably appears in
  the VSCode browser tools.
+ If =python.terminal.activateEnvironment= is on, it's available for tasks,
  but gets loaded twice for shells.

For extensions whose configuration depends on Guix manifests:

+ If I were to open =*.hcl= files for packer or terraform, then the editor
  won't be integrated. And why use Guix? Why containerize your dependencies
  and pin versions?
+ If I use a Guix profile with a link -- =guix shell -p= instead of =guix
  shell -m= then I should be able to guarantee that I at least have a
  consistent path to reference binaries for in =settings.json= for
  project-specific configurations -- but there's a chance this would differ
  from system to system and it impairs sharing project settings.

Vim users working with Nix flakes would encounter many similar issues when
they cross-over to VSCode, though maybe Nix has better tooling.

**** In Flatpak

Config will be in =$FLATPAK_USER_VAR/app/vscodium.codium/config/VSCodium=
which has the structure of the standard Chrome-based electron app.

VSCodium spawns from the environment, so when it runs the =/bin/bash= from
inside it's flatpak, it still has the parent environment that =flatpak run=
didn't override.

I would recommend avoiding Flatpak unless you know the CLI well. It adds
another layer of indirection in managing shell profiles for tasks.

** Screen

+ GNU [[https://www.gnu.org/software/screen/manual/screen.html#toc-Regions-1][manual]]

#+begin_src sh :tangle .screenrc
startup_message off
defmousetrack on

term screen-256color
#term xterm-256color
#term rxvt-unicode-256color

# enable bold colors (shouldn't be req.)
# attrcolor b ".I"

# when available: use x-scrolling mechanism
# termcapinfo xterm*|rxvt*|kterm*|Eterm* ti@:te@

# remove window/proc number from name in windowlist (C-a ")
windowlist string "%4n %h%=%f"
# windowlist string "%4n %t%=%f" # default

# index windows starting at 1
bind c screen 1
bind ^c screen 1
bind 0 select 10
screen 1

# should fix issues where text editor's don't properly reset the window
altscreen on

hardstatus off
hardstatus alwayslastline
hardstatus string '%{= kG}[ %{G}%H %{g}][%= %{= kw}%?%-Lw%?%{r}(%{W}%n*%f%t%?(%u)%?%{r})%{w}%?%+Lw%?%?%= %{g}][%{B} %m-%d %{W} %c %{g}]'

# TODO: dynamic titles for screen windows:
# https://www.gnu.org/software/screen/manual/screen.html#Dynamic-Titles
#+end_src

#+RESULTS:

*** Notes

+ Screen runs =C-a := commands in the context of the =env= that first started
  screen.
+ The =.screenrc= details should be shared in common for most systems, then you
  make changes and reload with =C-a :source ~/.screenrc= without spawning new
  processes.
+ Window customizations (splitting and assignment) do not survive detaching from
  a session, so window layout scripts ideally should avoid commands resulting in
  side-effects, so they are simple to re-source.
  - running =C-a :layout save $layout= will associate the current layout to the
    screen session, restoring it on reattach.
+ Archlinux [[https://bbs.archlinux.org/viewtopic.php?id=55618][discussion with user screenrc's]]

*** Scripts

+ These scripts can be included with =C-a :source /home/dc/.screen/layout.rc=.
+ Running =C-a :layout dump /home/dc/.screen/123.layout.screenrc= will save the
  current layout to a file.

**** Window arrangement for servers

Start =ssh-agent= before launching the screen session.

Then, source:

#+begin_src sh :tangle .screen/remote.layout.screenrc
split
split -h
#+end_src

Also, it may be possible to add =source ~/.screenrc= at the top, include the =ssh-agent= startup in the =.screenrc= and start with =screen -c .screen/remotelayout.screenrc=.

***** TODO complete after grokking GNU screen [[https://www.gnu.org/software/screen/manual/screen.html#Layout][regions/layouts]]

**** Start processes for web development

**** Setup SSH/GPG for a Yubikey

Useful to have a common =GPG_TTY= with more control over sharing ... though this
may cause problems with email clients or other programs. If it does, then some
issues could lead to pin lockouts.

So maybe it's only useful for controlling access to =ssh-agent=, though there's
probably a better way to set that up without problems (e.g. every
console/program has SSH/GPG agent vars/access)

* Shells
:PROPERTIES:
:header-args+: :comments link :mkdirp yes
:END:

** RC

If not running interactively, return

#+begin_src sh :tangle .bashrc :shebang #!/bin/sh
[[ $- != *i* ]] && return
shopt -s histappend

[[ "$TERM" == "dumb" ]] || export TERM="xterm-256color"

# RC
export DOTS_RC_D=$DOTS_CFG_SHELL/rc.d
[[ -f $DOTS_CFG_SHELL/_before_rc.d.sh ]] && source $DOTS_CFG_SHELL/_before_rc.d.sh
[[ -f $DOTS_CFG_SHELL/_load_rc.d.sh ]] && source $DOTS_CFG_SHELL/_load_rc.d.sh
#+end_src

*** Aliases

#+begin_src sh :tangle .config/sh/rc.d/aliases.sh :shebang #!/bin/sh
#* alias @ALIAS

#** color @ALIAS

# unless dumbterm
if [ "$TERM" != "dumb" ]; then
    # commandline color by default
    alias ls='ls --color=auto'
    alias dir='dir --color=auto'
    alias egrep='egrep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias diff='diff --color=auto'
    alias grep='grep --color=auto'
    alias vdir='vdir --color=auto'
    alias screen='screen -h 2000'
# else
    # no color
fi

#* docs @ALIAS
alias imacs='emacs -f info-standalone --eval="(load-theme (intern \"wombat\"))"'
manhtml() {
    [[ -z "$1" ]] && echo "Requires man page name" && return 1
    man -Thtml "$1" \
        | sed -e 's/margin-top: 1em//g' \
        | sed -E 's/(<br>|<hr>)//g' \
        | sed -E 's/<a href="#.*>//g'
}

#* ps @ALIAS

# pgrep -u $UID
pskill() {
    [[ -z "$1" ]] && echo "Requires command name" && return 1
    pkill -u $UID -x "$1"
}
alias psid='ps -opid,uid,command h'
# h sorts
alias pspri='ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm k pri'
alias ps_pri='ps -eo pri k +pri h | uniq -c'

# emacs stays at -4: https://github.com/Nefelim4ag/Ananicy
alias ps_nice='ps axo pid,comm,nice,cls --sort=-nice'
alias psnice='ps -o pid,comm,nice' # $pid

alias ptrgb="pstree -C age -pT"

#* renice @alias
# alias renoice="renice --priority 15 $(pgrep emacs-29)"

#* shell @ALIAS

#** redirect @ALIAS
alias wordcat="tee >(xargs -n1 cat) | wc -w"

#** curl @ALIAS

# use with parameter expansion: echo -e https://fdsa.com/path/to/{0,1,2,3,4,5}.jpg | curlist -o

# curl --remote-name-all --output-dir /data/xdg/Documents/cheatsheets/lisp/folding/ -K <( ... )
# <(echo -e https://page.com/path/to/{4,5,6,7,8,9,10,11}.jpg | sed -e 's/ /\n/g' | sed -E 's/^(.*)$/url="\1"/g')

#* data
alias tyxy="tidy --quiet yes --tidy-mark no --vertical-space yes -indent -xml"

#** jqyq @ALIAS

#** grep @ALIAS
alias grepnobin="grep -I"

#* system @ALIAS

#** updates @ALIAS
alias grubup="sudo update-grub"
alias upd='/usr/bin/update'

#* hardware @ALIAS
alias hw='hwinfo --short'
alias psmem10='ps auxf | sort -nr -k 4 | head -10'
alias psmem='ps auxf | sort -nr -k 4'

#** disk @ALIAS
alias iotopa='iotop -oa'
# atop

#* archive @ALIAS
alias tarnow='tar -acf '
alias untar='tar -zxvf '
alias wget='wget -c '

#* services @ALIAS
#** systemd @ALIAS
alias jctl="journalctl -p 3 -xb"
alias jctlu="journalctl --user -u"
alias sysu='systemctl --user'
# also: systemd-search-shared
alias sysupath='systemd-path user-shared'
alias sysdpath='systemd-path system-shared'
# sysu cat doom
# sysu show -p Type $doom
# sysu show -vp Type $doom # only values
# alias sysed='systemctl --user edit --drop-in=$overridename $svc'

#* pkg
#** pacman @ALIAS
alias fixpacman="sudo rm /var/lib/pacman/db.lck"
alias rmpkg="sudo pacman -Rdd"
alias cleanup='sudo pacman -Rns `pacman -Qtdq`'
alias rip="expac --timefmt='%Y-%m-%d %T' '%l\t%n %v' | sort | tail -200 | nl"

#* shelltools @ALIAS
alias pathtr="tr ':' '\n'"
alias shitbin='echo -e "\033c"'

#* crypto @ALIAS

#** ssh @ALIAS

alias sshddump='sudo sshd -T'
#alias sship='ssh -i $

#* gpg @ALIAS
alias gpga='gpg --armor'
alias gpguptty='gpg-connect-agent updatestartuptty /bye'
alias gpgrel='gpg-connect-agent reloadagent /bye'
alias gpgk='gpg-connect-agent killagent /bye'

#* git @ALIAS

# passes NUL byte to xargs, needs to be function
# alias gitls_bydate='git ls-tree -r --name-only HEAD -z | TZ=UTC xargs -0n1 -I_ git --no-pager log -1 --date=iso-local --format="%ad _" -- _ | sort'

#** git-stack @ALIAS
alias gkg='git stack'
alias gksy='git stack sync'
alias gkcfg='git stack --dump-config -'

# TODO: ascii git tree
# git log --graph --pretty=format:'%Cred%h%Creset%n %d' --abbrev-commit --decorate -n32 --all HEAD~

# Advanced command-not-found hook
# source /usr/share/doc/find-the-command/ftc.bash

#* git-stack @ALIAS
alias emacs-debug-wayland='WAYLAND_DEBUG=1 emacs --fg-daemon > $HOME/.cache/log/emacs.wayland.`date +%Y-%m%d-%H%M`.log 2>&1'

alias nodenpm_lsparse="npm ls -g --parseable | grep node_modules | sed -e 's/.*node_modules\///g'"
#+end_src

*** Functions

**** Completion

See [[https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html][Programmable Completion Builtins]]

#+begin_src sh :tangle .config/sh/rc.d/completions.sh :shebang #!/bin/sh
# all completions in guix system profile
# ls  /run/current-system/profile/share/bash-completion/{completions,helpers}

# files: {completions,helpers}
export GUIX_COMPLETE=/run/current-system/profile/share/bash-completion

tre() {
    local -a tree_opts=()
    local -a tree_args=()

    while [ "$#" -gt 0 ]; do
        if [[ "$1" = "--" ]]; then
            shift 1
            tree_opts=$@
            break;
        fi
        tree_args+=($1)
        shift 1
    done

    echo ${tree_opts[@]}
    echo ${tree_args[@]}
}
#+end_src


**** Git Repo

#+begin_src sh :tangle .config/sh/rc.d/functions.sh
# clear all the fat fingers, so sync happens without dired
repo_reset_repos() {
    [[ -z "$1" ]] && \
        printf "quoted glob pattern: \$1\nargs to git reset \$@" && \
        return 1

    local _pattern=$1
    shift 1

    # pattern is optional .... oh
    if [[ $# -gt 0 ]]; then
        # which is probably why there's no explicit command for this
        repo forall $_pattern -c git reset $@
    else
        repo forall $_pattern -c git reset --hard
    fi

}

# alias rprr=repo_reset_repos
#+end_src


**** Find

#+begin_src sh :tangle .config/sh/rc.d/functions.sh
find_dirs_with_ext() {
    [[ -z "$1" ]] && \
        printf "requires quoted regexp pattern for sed -E (e.g. '.*\.scm')" && return 1

    local _pattern=$1
    shift 1

    find . -name "*.scm" -type f -print \
        | sed -E 's/^(.*\/)'"$_pattern"'/\1/g' \
        | sort | uniq \
        | tree --fromfile .
}
#+end_src

**** IPC

#+begin_src sh :tangle .config/sh/rc.d/functions.sh
# from https://git.aweirdimagination.net/perelman/kill-child-jobs/src/branch/master/bash.sh
# set -e # um no

kill_child_jobs() {
    # From https://unix.stackexchange.com/a/544167
    while kill %% 2>/dev/null; do sleep 0; done
}
#+end_src
**** File Listing

#+begin_src sh :tangle .config/sh/rc.d/functions.sh
tre() {
    local -a tree_opts=()
    local -a tree_args=()

    while [ "$#" -gt 0 ]; do
        if [[ "$1" = "--" ]]; then
            shift 1
            tree_opts=$@
            break;
        fi
        tree_args+=($1)
        shift 1
    done

    echo ${tree_opts[@]}
    echo ${tree_args[@]}
}
#+end_src

#+begin_src sh :tangle .config/sh/rc.d/aliases.sh :shebang #!/bin/sh
#* tree @ALIAS

# nevermind, --prune removes empty subdirectories not containing -P $pattern
alias treef='tree --prune -aP'
#+end_src

*** Shell Prompt

Update PS1 according to [[https://github.com/direnv/direnv/wiki/PS1][direnv wiki]]

To check capabilities, see =man terminfo= and =infocmp=

#+begin_src sh :tangle .config/sh/rc.d/prompt.sh :shebang #!/bin/sh
export PS_INFO=""
export PS_PROMPT=""

PS_GIT=""
GIT_PS1_SHOWCOLORHINTS=1
GIT_PS1_DESCRIBE_STYLE=branch
GIT_PS1_SHOWUPSTREAM=name

PS_PROMPT="${LYELLOW}\A ${LGREEN}\u${RED}@${LCYAN}\h ${RED}:: ${YELLOW}\w"
if [ -n "$GUIX_ENVIRONMENT" ]; then
    PS_INFO="${LMAGENTA}g${RESTORE}"
fi

if [ "$TERM" = "dumb" ]; then
    PS1='$ '
else
    PS_GIT='$(__git_ps1 "«%s»") '
    PS_INFO="$PS_GIT $PS_INFO"
    PS1="$PS_INFO \n$PS_PROMPT"

    # calc number of cols with $((COLUMNS -n ))
    if [ -n "$PS_GIT" ]; then
       PS1="$PS1"
    fi
    PS1="$PS1${RED}$ ${RESTORE}"
fi

#+end_src

**** Ok, nevermind then

TFW trying to avoid side effects in function (... but then realizing you in bash)

#+begin_src sh :tangle .config/sh/prompt.sh :shebang #!/bin/sh

ps_update() {
    # $1: PS_PROMPT $2: PS_INFO (optional)
    if [ "$TERM" = "dumb" ]; then
        # || [ $# -ge 1 ]
        # || [ -z "${RESTORE}" ] # well that's unfortunate
        return # fail silently
    fi

    if [ -z "$PS_PROMPT" ]; then
       PS_PROMPT="<=> ${RESTORE}"
    fi

    local ps_new="$PS_PROMPT"
    if [ -n "$PS_INFO" ]; then
        psnew="$PS_INFO\n$psnew$"
    fi
    psnew="$psnew ${RED}$ ${RESTORE}"
    echo $psnew

    # using in .envrc makes and it becomes specific to my system.
}

# PS1="$(ps_update \"$PS_INFO\")"
# TERM=dumb
#+end_src

To use in direnv (untested....)

#+begin_example sh
PS_INFO="${PS_INFO}${LGREEN}[ foo ]${RESTORE} "
[[ -n "$(declare -F ps_update)" ]] && psnew="$(ps_update $PS_INFO)"
#+end_example

*** GPG/SSH

#+begin_src sh :tangle .bashrc :shebang #!/bin/sh
unset SSH_AGENT_PID
if [ "${gnupg_SSH_AUTH_SOCK_by:-0}" -ne $$ ]; then
  export SSH_AUTH_SOCK="$(gpgconf --list-dirs agent-ssh-socket)"
fi
#+end_src

*** Direnv

Load at end of =.bashrc=

#+begin_src sh :tangle .bashrc :shebang #!/bin/sh
[[ -e "$(command -v direnv)" ]] && eval "$(direnv hook bash)"
#+end_src

Reload =direnvrc= with =direnv reload=

**** Guix Direnv


Add =use guixs= to direnv capabilities in =.envrc=. Thanks [[https://sr.ht/~abcdw/rde/][abcdw/RDE]].

#+begin_src sh :tangle .config/direnv/direnvrc :shebang #!/bin/sh
# when using guix environment in a project, the downloaded environment
# will be cached in ./.guix-profile. delete it to update the profile
#
# https://github.com/direnv/direnv/wiki/GNU-Guix
use_guix() {
  local cache_dir="$(direnv_layout_dir)/.guix-profile"
  if [[ -e "$cache_dir/etc/profile" ]]; then
    # shellcheck disable=SC1091
    source "$cache_dir/etc/profile"
  else
    mkdir -p "$(direnv_layout_dir)"
    eval "$(guix environment --root="$cache_dir" "$@" --search-paths)"
  fi
}

# NOTE: if arguments like -L need to be passed to guix shell,
#   just use this one
use_guixs() {
  eval "$(guix shell "$@" --search-paths)"
}

use_guix_profile() {
  [[ $# -lt 1 ]] && echo "use_guix_profile requires argument" && return 1;
  local profile_path=$1
  shift 1
  [[ ! -e $profile_path ]] && echo "use_guix_profile requires extant profile path" && return 1;

  eval "$(guix shell -p "$profile_path" --search-paths)"
}

use_guix_manifest() {
  [[ $# -lt 1 ]] && echo "use_guix_manifest requires argument" && return 1;

  local manifest_file=$1
  shift 1

  [[ ! -e $manifest_file ]] && echo "use_guix_manifest requires extant manifest file" && return 1;

  eval "$(guix shell -m "$manifest_file" --search-paths)"
}

# NOTE need to install the profile with `guix environment --root`
# - then it's available to use with guix shell?
use_guixs_cached() {
  echo "$(direnv_layout_dir)"
  local cache_dir="$(direnv_layout_dir)/.guix-profile"
  if [[ -e "$cache_dir/etc/profile" ]]; then
    # shellcheck disable=SC1091
    source "$cache_dir/etc/profile"
  else
    mkdir -p "$(direnv_layout_dir)"
    eval "$(guix shell --root="$cache_dir" "$@" --search-paths)"
  fi
}
#+end_src

** Bash

+ GNU [[https://www.gnu.org/software/bash/manual/bash.html][manual]]

*** =.bash_profile=

In case an installation automatically creates =.bash_profile=

#+begin_src sh :tangle .bash_profile :shebang #!/bin/sh
if [ -f $HOME/.profile ]; then . $HOME/.profile; fi
#+end_src

** Zsh

** Scripts

* Environment

** main

#+begin_src sh

#+end_src

** devtools

#+begin_src scheme :tangle ".config/guix/manifests/devtools.scm"
(specifications->manifest
;;** git
 '("git"
  "git-lfs"
  "git-repo"
  "git-stack-bin"

;;** fetch
  "curl"

  ;; for emacs pdf-tools
  ;; "cairo"
  ;; "libpng"
  ;; "poppler"

;;** for pyenv builds

;; I thought some of these were already brought in
  "zlib"
  "libffi"
  "xz"
  "expat"
  "libxml2"
  "bzip2"
  "gdbm"

;; I want to learn TCL anyways, but maybe this should be in
;; another profile
  "tk"
  "ncurses"

;;  "poetry"

;;** pkg metadata
  "pkg-config"

;;** build essential
  "gettext"
  "autoconf"
  "automake"
  "glibc"
  "gcc-toolchain"
  "cmake"
  "make"
  "perl"

;;** lib
  "libtool"

;;** tty
  "libvterm"
  "screen"

;;** crypt/hash
  "libxcrypt"

;;** environment
  "direnv"
  "stow"

;;** log
  "rsyslog"

;;** search
  "fd"
  "ripgrep"
  "the-silver-searcher"

;;** media
  ;; TODO consider moving to a media profile
  "ffmpeg"

;;** compute
  ;; TODO move openblas to a data science profile?
  "openblas"
  "lapack"

;;** data
  "jq"
  "python-yq"
  "sqlite"

;;** file
  "tree"
  "file"
  "perl-image-exiftool"
  "lsof"
  "lsofgraph"

;;** disk
  "btrfs-progs"

;;** data vis
  "plantuml"
  "graphviz"
  "d2-bin"

;;** ssh
  "openssh"
  "openssl"
  "rsync"

;;** pass
  "password-store"
  "age"
  "pass-age"
  "age-plugin-yubikey-bin"
  "sops"

;;** compression
  "zip"
  "unzip"
  "p7zip"

  ;; MIME problems when building. TLDR: i should've migrated to guix home earlier
  ;;
  ;; E   AssertionError: 'application/gzip' != 'application/x-tar'
  ;; E   - application/gzip
  ;; E   + application/x-tar
  ;; E    : MIME type for archive `t.tar.gz.foo' should be application/x-tar, but
  ;; "patool"

;;** vm

  ;; should fix a gdx-pixbuf issue for virt-manager
  "gdk-pixbuf"
  "virt-manager"

;;** node
  "node"

;;** network
  "bind:utils"

;;** octave
  "octave"
  ))
#+end_src

** devdebug

#+begin_src scheme :tangle ".config/guix/manifests/devdebug.scm"
(specifications->manifest
    '(
      "gdb"
      "patchelf"
      "ltrace"
      "strace"
      ;; "ftrace"
      ;; "uftrace"
      "traceroute"
      "sysprof"
      ;; "perf"
      ;; "bpftrace"
      ;; "elfutils"

      ;; "kernelshark"
      ;; "traceshark"
      ;; "babeltrace"
      ;; "tracecompass"

      ;; "hddtemp"
      ;; "lmsensors"

      "gparted"
      "mmc-utils"
      "f3"

      ;; i2c needs a guix service, which requires a kernel module
      ;; - see guix system OS declarations
      "i2c-tools"
      "ddcutil"
      "ddcui"

      "tcpdump"

      "inotify-tools"
      "netcat"
      "socat"
      ))
#+end_src

** netdebug

#+begin_src scheme :tangle ".config/guix/manifests/netdebug.scm"
(specifications->manifest
 '(
   "arp-scan"
   ))
#+end_src

** XDG

I can't really imagine a desktop/terminal context where I wouldn't want XDG
utils in the environment, but this is split out anyways...

+ compton :: an alternative compositor for X
  - incompatible in Wayland, since it doesn't offer modular compositors
+ redshift :: control color temperature according to surroundings.
  - requires =libxcb= X11 client lib
  - for wayland: =gammastep= or =wlsunset=
+ gucharmap :: unicode character map (GTK)
+ fontmanager :: provides GTK tools to aid configuration of fonts
+ brightnessctl :: lightweight brightness control tool

** XKB

#+begin_src scheme :tangle .config/guix/manifests/xkb.scm
(specifications->manifest
 '(
   "xkb"
   "xkbcomp"
   "xkeyboard-config"
   "setxkbmap"

   "xev"
   "xkb-switch"
   "xkblayout"
   "xkbutils"
   "xkbprint"

   ;; "xkbevd"
   ))
#+end_src

** Languages

Manifests for language environments

* TUI

** Env

This section should configure scripts and a guix profile intended to be loaded
in a terminal-only interface.

#+begin_src scheme :tangle .config/guix/manifests/tui-env.scm
(specifications->manifest
 '(
   ;"htop"
   ;"lnav"
   ))
#+end_src

** Apps

#+begin_src scheme :tangle .config/guix/manifests/tui-apps.scm
(specifications->manifest
 '(
   ;"lnav"
   ))
#+end_src

*** Htop

*** LNAV

+ [[https://docs.lnav.org/en/latest/formats.html][Docs]]
  - The =$HOME/.config/lnav/= directory should exist before =.dotfiles= is stowed.
  - It contains state, history, views and usage data.
  - Only the configs/formats should be added to git.
+ [[https://docs.lnav.org/en/latest/formats.html][New Formats]] can be installed into =$HOME/.config/lnav/formats/installed=
  - from files: =lnav -i myformat.json=
  - from a repository
  - from the [[https://github.com/tstack/lnav-config][extra]] repository: =lnav -i extra=
+ Custom formats can be added into =$HOME/.dotfiles/.config/lnav/formats/=
+ New Configs can be installed into =$HOME/.config/lnav/configs/installed/=
+ Custom configs can be added into =$HOME/.dotfiles/.config/lnav/configs/=

#+begin_src sh :results output :exports none
lnav -i extra
#+end_src
