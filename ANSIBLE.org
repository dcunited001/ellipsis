:PROPERTIES:
:ID:       2b7dae76-003f-4714-b621-c046d855fe3e
:END:
#+TITLE: Ansible: setup a portable environment on Guix
#+CATEGORY: slips
#+property: header-args            :tangle-mode (identity #o400) :mkdirp yes
#+property: header-args:conf       :tangle-mode (identity #o600) :mkdirp yes
#+property: header-args:sh         :tangle-mode (identity #o500) :mkdirp yes
#+property: header-args:shell      :tangle-mode (identity #o500) :mkdirp yes
#+property: header-args:scheme     :tangle-mode (identity #o500) :mkdirp yes
#+property: header-args:emacs-lisp :tangle-mode (identity #o600) :mkdirp yes
#+TAGS:


Don't put your secrets on a LUKS drive. Either vault, ansible-vault, pass or
some other means is much better.

+ Vault requires certificate deployment, but integrates nicely in k3s or K8S.
+ Ansible Vault permits retrieval of secrets GPG-encrypted at rest.

It is quite a relief to trust GPG on a smartcard though.

**** TODO finish refactoring this (and hopefully use it for once)

* Goals For Ansible

The goal here is to have some scripts for facilitating the creation of new
Ansible projects, although I'm beginning to realize you probably don't have too
many of them, unless the networks are for some completely separate work context.

My guix channel should eventually contain things like custom kernal configs,
single-purpose Raspberry Pi systems, This is all a bit tough to maintain if
tests aren't automated. While there are CI/CD tools for testing Guix stuff, it's
all very specific to Scheme, which IMO is great, but it's not yet agnostic to
cloud/network/os.

I would like to test my Guix System & Home dotfiles using =ansible= and
=libvirt=. "Ansible does automation" you say? ... but it also connects to any
shell, which should not exclude I2C given enough ingenuity. And further to the
point: to facilitate idempotence, Ansible asserts state with no host
dependencies for connection. Though it would seem to lack the ability to
guarantee complete teardown/setup, this is an interesting problem.

My spidey senses tell me people might pay for that =libvirt= automation stuff --
not for dotfiles, but for automated testing of virtualized ARM/Embedded systems
--

So I may actually end up with many ansible projects.

* Org Babel Config

Ensure the values below are set. They're required for the =:tangle= output
paths. The emacs-lisp blocks below are used further down . If emacs is already
open, then running =M-: (setenv "VAR" "value")= will set the environment var for
the whole process. This is also useful for setting:

#+begin_src emacs-lisp
(setq-local ansible-prefix (or (getenv "ANSIBLE_PREFIX") "build/ansible")
            org-confirm-babel-evaluate nil)
#+end_src

I am building to another directory for now (not in my dotfiles), but I may
switch to =./build/ansible= later.  I like maintaining a layer of separation
here because it's much less likely that I'll commit something I don't intend to,
which for better or worse happens less frequently than it may seem. I'm not sure
there are any secrets in my repos unless in the git index somehow, but I've
always staged by line/hunk ... so.

** Var Setup

To add in bash scripts as =<<ansible-prefix>>=

#+name: ansible-prefix
#+begin_src emacs-lisp :results value silent
ansible-prefix
#+end_src

#+name: secrets-home
#+begin_src emacs-lisp :results value silent
secrets-home
#+end_src

** Build

The intent here is to build a portable ansible config at =ansible-prefix=.  When
tangling to paths other than =ansible-prefix= and =.config/ansible=, everything
sticks to =FHS= and =XDG= for clarity.

+ .local/bin :: scripts that exec
+ .local/lib/ansible :: scripts that source

Generally, most ansible project files will be generated in =.config/ansible= and
can then be copied into =ANSIBLE_HOME= when needed.

The build can be dumped into a folder or stowed:

#+begin_src sh
ANSIBLE_HOME=$HOME/.ansible
stow --dir $ANSIBLE_PREFIX --target $ANSIBLE_HOME
#+end_src

Anything that ends in =*.eg= or contains =*.eg.*= is added to the stow ignore list:

#+begin_src gitignore :tangle (expand-file-name ".stow-local-ignore" ansible-prefix)
# perl regex
*.eg
*.eg.*
#+end_src

Stowing into the =$ANSIBLE_HOME= might not work out, since it contains
directories like:

+ collections
+ roles
+ plugins
+ tmp
+ galaxy_cache
+ pc
+ ANSIBLE_PLAYBOOK_DIR

* Environment

Ensure =ANSIBLE_HOME= is set. Almost everything will be relative to that.

Depending on its value and whether a config file is read, then files will likely
be created in =$HOME/.ansible/tmp= and =$XDG_CONFIG_HOME/ansible=.

Using direnv can help jump between various ansible projects. If you set
=ANSIBLE_CONFIG=, it's very likely that you'll want multiple configs like
=ansible.debug.cfg= so use =-c $config= to do that.

#+begin_src sh :tangle (expand-file-name ".envrc.eg" ansible-prefix)
export ANSIBLE_HOME=$PWD
export ANSIBLE_CONFIG=$ANSIBLE_HOME/ansible.cfg
PATH_add .bin
use_guix_profile $GUIX_EXTRA/ansible/ansible
#+end_src

** Python

On guix system (load after ansible profile)

#+begin_src sh :tangle (expand-file-name ".envrc.eg" ansible-prefix)
export VIRTUAL_ENV=.genv
layout python3
#+end_src

An additional =.venv= profile could be set up for other environments like VS
Code. After the =.genv= profile is created, run the following

#+begin_example shell
pip install --upgrade pip
pip install -r requirements.txt
#+end_example

The requirements file has been generated from:

#+begin_src shell
pip install ansible-core ansible-navigator ansible-lint yamllint dnspython
#+end_src

** Guix Profile

See "Ansible On Guix" for info on its dependencies. The =venv= above is required
to get =ansible= and other tools like =ansible-navigator=, so I'm not really
using this.

#+begin_src scheme :tangle (expand-file-name ".config/guix/manifests/ansible.scm" ansible-prefix)
(specifications->manifest
 '(
   "ansible"
   "man-db"
   ))
#+end_src

** Emacs



#+begin_src emacs-lisp :tangle .dir-locals.eg
((yaml-mode . ((flycheck-checker . 'yaml-yamllint))))
#+end_src

** Ansible LSP

This is instantiated via =docker compose=

*** Docker Compose

#+begin_src yaml :tangle (expand-file-name ".config/ansible/docker-compose.yml" ansible-prefix)

#+end_src


** Ansible Navigator

[[github:ansible/ansible-navigator][ansible/ansible-navigator]] is a TUI for exploring the local ansible
environment. It launches automations via a docker container by default.

#+begin_src yaml :tangle (expand-file-name ".config/ansible/ansible-navigator.eg.yml" ansible-prefix)
---
ansible-navigator:
  editor:
    command: gmacsclient -nw {filename} +{line_number}
    console: true
#+end_src

Judging by the source, opening a file in =$EDITOR= doesn't allow you to save
changes, meaning you'll have to save over the file in its path. The app is for
quick exploration of a project or environment, which it does well.

To run any ansible commands, by default, it uses the
=ghcr:io/ansible/creator-ee:v0.17.0= image.

* Ansible

** Config

Some na√Øve example settings:

#+begin_src conf :tangle (expand-file-name ".config/ansible/ansible.cfg.eg" ansible-prefix)

[tags]

[defaults]
nocows=1

# * inventory
inventory=inventory.yml

# * playbooks

# * facts

# * logs

# ** logs: options

# ** logs: ansible validation

# ** logs: yaml validation

# ** logs: jinja2 validation

# * auth

# ** vault

# ** connection
transport=ssh

# * roles & collections

# * modules & module_utils

# * plugins

# ** filters

# ** group vars:

# ** plugin paths

# * [defaults]

[privilege_escalation]


[persistent_connection]


[connection]


[colors]


[selinux]


[diff]


[galaxy]

display_progress=True


[inventory]

any_unparsed_is_failed=True

[netconf_connection]


[paramiko_connection]


[jinja2]

#+end_src

*** Comparing against defaults

Run to generate defaults and diff.

#+begin_src sh :results output silent :file (expand-file-name ".config/ansible/ansible.cfg.defaults" ansible-prefix)
ansible-config init --disabled -t --format=ini
#+end_src

The =--format env= option can be evaluated or appended to a =.envrc=.

*** Dumping configs

Here the formats are json, yaml, or ini and are incompatible with the above, though

#+begin_src sh
ansible-config dump -c $config --only-changes -t --format=$format
#+end_src

** Plugins

#+begin_example conf
# [callback_slack]
# channel = #thechannel
# username = fdsa
# webhook_url = env:SLACK_WEBHOOK_URL

# [callback logstash]
# port = env:LOGSTASH_PORT
# server = env:LOGSTASH_SERVER
# type = env:LOGSTASH_TYPE
#+end_example

*** TODO include other collections/roles paths?


*** PFSense Lookup Plugin

To show docs on the =pfsensible.core.pfsense= lookup plugin, run =ansible-doc -t
lookup pfsensible.core.pfsense=

The =pf.yml= file describes network topology/state and is required to use the
lookup plugin. An example is available in the docstrings at the =pfsense.py=
link. Four sections are required in =pf.yml=:

+ pfsenses
+ rules
+ hosts_aliases
+ ports_aliases

Since the plugin source contains a =main()= and whatnot, then once the plugin is
set up, you can run command's like what's below. This allows you to quickly dump
the state.

#+begin_src shell
pfpath=collections/ansible_collections/pfsensible/core/plugins/lookup
$pfpath/pfsense.py pf.yml pf1
#+end_src


**** TODO fix description:
+ [ ] copy to lookup_plugins
+ [ ] install dnspython

To make the [[https://github.com/pfsensible/core/blob/master/plugins/lookup/pfsense.py][pfsense.py]] lookup plugin available to run as a script, either:

+ copy the lookup plugin =$pfpath/pfsense.py= to =./lookup_plugins=
+ or append the plugin's path within your =collections= directory to the
  =lookup_plugins= path in your =ansible.cfg=.
+ use =ansible-runner run -m pfsense= but you'll need to fix the module path. i
  couldn't get this to work and needed to move on. there aren't many examples of
  using =ansible-runner= where a script is run with =main()=


** Inventory

An example of inventory.

#+begin_src conf :tangle (expand-file-name ".config/ansible/inventory.yml.eg" ansible-prefix)
all:
  ansible_port: 2020
  # ansible_user: ansible
  # ansible_host: 123.123.123.123
  hosts:
    host1.local:
      ansible_user: root
    host2.local:
      ansible_user: ansible
    vm1.vm.local:
      ansible_user: ansible
    guix1.vm.local:
      ansible_user: ansible
    router1.net.local:
      ansible_user: admin
    router1.net.local:
      ansible_user: admin
    host1.k3s.local:
      ansible_user: ansible
    vm1.cloud.com:
      ansible_user: ansible

  children:
    cisco:
      # TODO: shell-only
      hosts:
        router1.net.local:
          ansible_user: ansible

    ddwrt:
      # TODO: ash only (not bash)
      hosts:
        router2.net.local:
          ansible_user: admin

    guix:
      ansible_python_interpreter: /run/current-system/profile/bin/python3
      hosts:
        host2.local:

    centos:
      hosts:
        host1.local:

    vm:
      hosts:
        vm1.vm.local:
        vm2.vm.local:
          ansible_python_interpreter: /run/current-system/profile/bin/python3

    # kubernetes example at https://github.com/techno-tim/k3s-ansible
    k3s:
      hosts:
        host1.local:
#+end_src

And then =group_vars/*.yml=, though =system_timezone= should be fetched
dynamically and stored as a fact.

#+begin_src yaml :tangle (expand-file-name ".config/ansible/group_vars/all.yml" ansible-prefix)
---
system_timezone: "America/New_York"

#+end_src

To see the hostvars applied to a group, use the =debug= module

#+begin_src shell
group=all

# for all vars
ansible $group -m debug -a "var=hostvars"

# for a specific var inherited from a group
ansible $group -m debug -a "var=system_timezone"
#+end_src


* Setup

** External Services

*** Galaxy

Getting access to Galaxy from behind a firewall is kind of a mess. It works
occasionally, but there's quite a bit of CDN magic that happens. You'll need a
mirror. However ... and I don't know why I didn't just switch gears earlier
... you can just pop the controller off the subnet. A protected Ansible AWX
would be a bit different. See the =pulp/pulp_

The Ansible Galaxy url's are nice and mnemonic: =galaxy.ansible.com/$namespace/$collection=

#+begin_src yaml :tangle (expand-file-name ".config/ansible/requirements.yml.eg" ansible-prefix)
---
collections:

  # basic
  - name: community.general
  - name: ansible.posix
  - name: ansible.netcommon
  - name: ansible.utils

  # container/vm
  - name: kubernetes.core
  - name: containers.podman
  - name: community.grafana
  - name: community.libvirt

  - name: pfsensible.core

  # security
  - name: community.hashi_vault
  - name: community.crypto
  - name: devsec.hardening

#roles:

#+end_src

Other collections

+ awx.awx
+ openvswitch.openvswitch
+ lvrfrc87.git_acp

**** TODO potentially refactor to meta/requirements.yml and meta

*** Ansible Vault

*** AWX

** Playbooks

Hmmmm... thanks [[https://bruxy.regnet.cz/web/linux/EN/bash-cheat-sheet/][Bash Cheatsheet]]. Noam Chomsky gently weeps colorlessly for
Tarzan-child of wilderness (reference to alienation)

#+begin_src sh :var prefix=ansible-prefix
unset $dryrun
#prefix=
#dryrun=echo
#dryrun=
centos=$prefix/roles/centos
gcloud=$prefix/roles/gcloud
virt=$prefix/roles/virt
qemu=$prefix/roles/qemu

role_dirs="tasks,handlers,templates,files,vars,defaults"
dircmd=${dryrun-"mkdir -p"}
filecmd=${dryrun-"touch"}

if [ -e $prefix ]; then
    echo "creating template at $prefix"
    $filecmd $prefix/{homelab,cloud,virt,qemu}

    # make root directory
    $dircmd $prefix/{group_vars,host_vars}
    $dircmd $prefix/{library,module_utils,filter_plugins,tasks}

    # make role directories
    $dircmd {$centos/,$gcloud/,$virt/,$qemu/}{tasks,handlers}
    $dircmd {$centos/,$gcloud/,$virt/,$qemu/}{templates,files,vars,defaults}
    $dircmd {$centos/,$gcloud/,$virt/,$qemu/}{meta,library,module_utils,lookup_plugins}

    # this also works
    # $filecmd {$centos/,$gcloud/,$virt/,$qemu/}{tasks,handlers}/main.yml
else
    echo "set prefix"
fi

#+end_src

#+RESULTS:
: creating template at /mnt/secrets/test

I'm sure there's a better way to do this, but i've looked. In the various
attempts at learning ansible, I've way too much time looking for templating
tools that were not ad-hoc github collections

**** PFSensible Ports Playbook

I couldn't really get the =pfsensible= lookup plugin to work -- too many parsing
issues. So I gave up. However, the aggregate tasks still work.

This is a fairly standalone playbook, which is difficult to come by for PFSense,
though it would need to be run before other pfsense plugins. This is really the
difficulty in managing PFSense XML: there are logical dependencies between the
names used in firewall rules.

Some of the protocols lack IP protocol number specifications -- for GRE, for
example. Here's the key for the protocol names:

+ p_ :: tcp/udp (or non-specified)
+ t_ :: tcp
+ u_ :: udp

#+begin_src yaml
---
- hosts: pfsense
  gather_facts: true
  connection: ssh

  tasks:
    - name: "setup port aliases"
      pfsensible.core.pfsense_aggregate:
        aggregated_aliases:
          - { name: p_dns, type: port, address: 53, state: present }
          - { name: t_ssh, type: port, address: 22, state: present }
          - { name: u_ntp, type: port, address: 123, state: present }
          - { name: u_ipsec, type: port, address: 500 4500, state: present }
          - { name: p_awx, type: port, address: 9191, state: present }
          - { name: p_cockpit, type: port, address: 9090, state: present }
          - { name: p_prox_coro, type: port, address: 5404-5405, state: present }
          - { name: p_prox_web, type: port, address: 8006, state: present }

          - { name: p_synct_gui, type: port, address: 8384, state: present }

          - { name: t_synct, type: port, address: 22000, state: present }
          - { name: u_synct, type: port, address: 21027, state: present }
          - { name: u_dchpv6, type: port, address: 546-547, state: present, descr: "DHCPv6 546-547 (UDP)" }
          - { name: p_gnunet, type: port, address: 2086 1080, state: present, descr: "GNUnet" }
          - { name: p_https, type: port, address: 443, state: present }
          - { name: p_http, type: port, address: 80, state: present }
          - { name: t_hkps, type: port, address: 11371, state: present }
          - { name: t_imap, type: port, address: 143, state: present }
          - { name: t_imaps, type: port, address: 993, state: present }
          - { name: t_irc, type: port, address: 6667, state: present }
          - { name: t_irc_all, type: port, address: 6660-6669 7000, state: present }
          - { name: u_mdns, type: port, address: 5353, state: present }
          - { name: t_ldap, type: port, address: 389, state: present }
          - { name: t_ldaps, type: port, address: 636, state: present }
          - { name: t_smtp, type: port, address: 25, state: present }
          - { name: t_snmps, type: port, address: 465, state: present }
          - { name: t_snmps_sub, type: port, address: 587, state: present }
          - { name: t_nntp, type: port, address: 119, state: present }
          - { name: t_nntps, type: port, address: 563, state: present }
          - { name: u_openvpn, type: port, address: 1194, state: present }
          - { name: t_pop3, type: port, address: 110, state: present }
          - { name: t_pop3s, type: port, address: 993, state: present }
          - { name: t_postgres, type: port, address: 5432, state: present }
          # PPTP also uses IP protocol 47 (GRE)
          - { name: t_pptp, type: port, address: 1723, state: present }
          - { name: t_rdp, type: port, address: 3389, state: present }
          - { name: t_rsync, type: port, address: 873, state: present }
          - { name: u_snmp, type: port, address: 161-162, state: present }
          - { name: t_snmp, type: port, address: 161, state: present }
          - { name: t_squid, type: port, address: 3128, state: present }
          - { name: p_syslog, type: port, address: 514, state: present }
          - { name: u_tftp, type: port, address: 69, state: present }
          - { name: u_traceroute, type: port, address: 33434-33524, state: present }
          - { name: t_vnc, type: port, address: 5900-5999, state: present }
          - { name: t_vncl, type: port, address: 5500, state: present }
          - { name: t_bgp, type: port, address: 179, state: present }
          - { name: t_ceph, type: port, address: 6789 3300 6800-7300, state: present }
          - { name: t_ceph_extra, type: port, address: 6800-7300, state: present }
#+end_src


* Ansible on Guix

Python will need to be installed separately (which is good)

|--------------+---------+----------------------------|
| package      | version | desc                       |
|--------------+---------+----------------------------|
| ansible      |   7.4.0 | provides ansible-community |
| ansible-core |  2.14.4 | provides ansible-core      |
|--------------+---------+----------------------------|

** Build a relocatable guix profile:

I would generally recommend against going through this, since =guix shell=
basically gains the same benefits. So I removed the loading from the =init-ansible.sh= script

However, it does provide a portable Ansible with consistent dependencies and
controllable environment. It's a generally interesting facet of Guix. I guess
other package archives could basically install to an arbitrary path, but this
generally needs to be provided ahead of time, unless stowed somewhere.

+ --system aarch64-linux :: makes the manifest portable to arm64
+ --relocatable :: twice enables binaries requiring user
  namespaces to function with a fallback execution engine
  - you may want the -RR relocatable option
+ -S :: creates links from the profile within the tar to the
  dependences in the guix packages

#+begin_src sh :eval no
guixpkg=$(guix pack --relocatable --system=x86_64-linux --compression=gzip --save-provenance \
      -L $HOME/.dotfiles -m $SECRETS_HOME/.config/guix/manifests/ansible-usb.scm \
      -S .bin=bin)
if [ ! -e $SECRETS_HOME/pkg ]; then
    mkdir -p $SECRETS_HOME/pkg
fi
cp $guixpkg $SECRETS_HOME/pkg
#+end_src

The package is built to =/gnu/store= and is in =$guixpkg=. Now unpack:

#+begin_src sh :eval no
tar -C $SECRETS_HOME/pkg -xzvf $guixpkg
#+end_src

The profile will be in =./gnu/store/*profile=. If there are multiple profiles
found in =$SECRETS_HOME=, then searching the =.tar= is a better way to find the
profile.

#+begin_src sh :eval no
guixprofile=$(tar --list -zf $guixpkg | grep 'profile/bin' | cut -d/ -f4)
ln -s $SECRETS_HOME/pkg/gnu/store/$guixprofile $SECRETS_HOME/.guix-ansible
#+end_src

After unpacking, the guix profile can be found more exactly with:

#+begin_src sh :eval no :tangle no
guixprofile=$(find $SECRETS_HOME/pkg/gnu/store -name "*-profile" -type d)
#+end_src

Then source the =$guixprofile/etc/profile= from a script. Some dependencies may
require symlinking =-S lib=lib= or =-S libexec/libexec=.

Test the profile's binaries in a clean shell with:

#+begin_src sh :eval no
guix shell --profile=.guix-ansible -- bash
#+end_src
