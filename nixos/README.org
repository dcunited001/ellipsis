


* Misc

** Flake

not using flakes for systems right now. doing so basically requires updating
system configurations at the same time as =home-manager= rebuilds

#+begin_src nix
{
  description = "Ellipsis NixOS Systems";
  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs/nixos-25.05";
    nix-flatpak = {
      url = "github:gmodena/nix-flatpak?ref=latest";
      inputs.nixpkgs.follow = "nixpkgs";
    };
  };

  # nixosConfigurations.<hostname>.config.system.build.toplevel
  # must be a derivation. can output:
  #
  # - modules: modules to build for output
  # - system: build for arch
  # - specialArgs: pass to system input
  #
  # nixosConfigurations.<hostname> is a fixed interface (config needs to go
  # into the modules listed

  # https://nixos.wiki/wiki/Flakes#Output_schema
  # <system> = [ "$arch" ]
  
  outputs = {
    nixpkgs,
      nix-flatpak,
      ...
  }@inputs {
    # system = [ "x86_64-linux" ];
    # 
  };
}
#+end_src


* Guix

** System Guix

See ./modules/services/guix.nix

=stateDir= forces compilation of guix when the pin changes... but I really
need the system entirely on one partition.

** User Guix

#+begin_example nix
{pkgs,...}:
{
user.users.dc.packages = [
  # ...
  pkgs.guix

  # overrides are bad (this is wrong) ...
  #   and idk, but if I superstitiously repeat pkgs.foobar,
  #   then for now, super douple plus good
  # pkgs.guix.override { stateDir = "/gnu/var"; }
}
#+end_example

*** Fix Activation script

See [[https://discourse.nix.org/t/why-does-nixos-not-set-xdg-config-home-by-default/45296][Why does NixOS not set =$XDG_CONFIG_HOME= by default]]

Maybe this occured because I ported in my home directory. I removed
=~/.profile= to check the environment.

=/nix/profile/bin=

- should be =$XDG_CONFIG_HOME/nix/profile/bin=
- the link =$XDG_CONFIG_HOME/nix/profile= doesn't exist.
- i'm not sure whether it's supposed to link to
  =/nix/var/nix/profiles/per-user/$USER/channels=

=/guix/current/bin=

- same thing: should link to =$XDG_CONFIG_HOME/guix/current/bin=
- the link =$XDG_CONFIG_HOME/guix/current= /does/ exist
- the link gets created by the activation script, which never actually
  creates the =/gnu/var/guix/profiles/per-user/$USER/current-guix=. i
  set =services.guix.stateDir = /gnu/var= so it's a bit different. that
  threw me for a loop when debugging.

so for me, I needed to manually create that by running:

#+begin_src sh
# in bash, fresh login
$prof=$XDG_CONFIG_HOME/guix/current
guix package -p $prof -i guix # install the package

# ensure path is right

GUIX_PROFILE=$prof
source $prof/etc/profile

# now guix pull works
guix pull

# logout of vty & window manager, login with fresh env
echo $PATH | tr ':' '\n'

# the profile is still incorrect in the path (since the activation script was created incorrectly...)
#+end_src

maybe it was my install, idk. the process for =nix= is likely similar. I
have a feeling once the correct =$PATH= is exported, then a system
update will allow the nix builder to build correctly

**** Original =$PATH=

testing file exists using =stat $(echo $PATH | tr ":" " ")=

| y   | link points to file that exists |
| !!! | invalid link                    |

root $PATH

| y   | /run/wrappers/bin                      |
| !!! | /guix/current/bin                      |
|     | /root/.guix-home/profile/bin           |
|     | /root/.guix-profile/bin                |
|     | /root/.local/share/flatpak/exports/bin |
| y   | /var/lib/flatpak/exports/bin           |
|     | /root/.nix-profile/bin                 |
| !!! | /nix/profile/bin                       |
|     | /root/.local/state/nix/profile/bin     |
|     | /etc/profiles/per-user/root/bin        |
|     | /nix/var/nix/profiles/default/bin      |
| y   | /run/current-system/sw/bin             |

user $PATH

| y   | /home/$USER/.local/bin                       |
| y   | /run/wrappers/bin                            |
| !!! | /guix/current/bin                            |
|     | /home/$USER/.guix-home/profile/bin           |
|     | /home/$USER/.guix-profile/bin                |
| y   | /home/$USER/.local/share/flatpak/exports/bin |
| y   | /var/lib/flatpak/exports/bin                 |
|     | /home/$USER/.nix-profile/bin                 |
| !!! | /nix/profile/bin                             |
|     | /home/$USER/.local/state/nix/profile/bin     |
| y   | /etc/profiles/per-user/$USER/bin             |
|     | /nix/var/nix/profiles/default/bin            |
| y   | /run/current-system/sw/bin                   |


**** User Guix =stateDir= mismatch

#+begin_quote
This was what I was speculating...

I actually did end up linking =/var/guix -> /gnu/var/guix= instead of creating
a new subvolume at =/var/guix=. it seems to work.
#+end_quote

The system has a single store with various GC roots. Usually have two main
profiles. I don't think installing Guix with =nix home-manager= is going to
work.

+ A symlink seems to work to fix the =stateDir= mismatch between the system &
  user guix: =sudo ln -s /gnu/var/guix /var/guix=. It seems to work...
  avoiding the override.
  - i'm seeing a build failure when updating user's default profile.
  - using =guix gc --verify={contents,repair}= somewhat frequently probably
    couldn't hurt. store corruption is the main worry, esp. if sharing between
    systems...
  - it also eliminates the recompile of guix (system+user) for at least user
    (guix is pinned on nix). 
+ I have confidence that the =/var/guix= path is =12-factor= ...
  - sharing b/w systems is somewhat out of scope for design.
  - the host can share a store to a hosted VM. CI requires special GC
    configuration (& other concerns) for storage replication & distributed
    substitutes. So there are at least two use cases that require decoupling.
  - I'm mostly curious.

in theory, I can have btrfs subvolumes for /var on guix system the sqlite db
cache needs to match for both nix/guix systems... probably not a great idea,
but as long as sqlite cache is in tact, it should work.


** Eww & Yuck

+ A little complicated, but so is any event-driven system.

*** Systemd

+ This creates a systemd service that links the =per-user= profile path.

#+name: ewwBin
#+begin_src emacs-lisp
;; :noweb-ref ewwBin
(format "/etc/profiles/per-user/%s/bin/%s" (getenv "USER") "eww")
#+end_src

#+begin_src toml :tangle (format "%s/systemd/user/%s" (getenv "XDG_DATA_HOME") "ewwbar.service") :noweb yes
[Unit]
Description=EWW Daemon
After=graphical-session.target

[Service]
ExecStart=<<ewwBin()>> daemon --no-daemonize --debug
# eww close-all is sufficient to clean up, systemd needs to kill the process
ExecStop=<<ewwBin()>> close-all
Restart=on-failure

[Install]
WantedBy=graphical-session.target
#+end_src

*** CLI
**** TODO Move eww/yuck ish to notes

Widget control

| close-all | Close all windows, without killing the daemon |
| close     | Close the given windows                       |
| open-many | Open multiple windows at once.                |
| open      | Open a window                                 |

State

| active-windows | Show active window IDs; outputs =<window_id: <window_name>= |
| get            | Get the value of a variable if defined                      |
| list-windows   | List the names of active windows                            |
| poll           | Update a polling variable using its script                  |
| state          | Prints the variables used in all currently open window      |
| update         | Update the value of a variable, in a running eww instance   |

Structure

| debug | Print out the widget structure as seen by eww              |
| graph | Print out the scope graph structure in graphviz dot format |

Daemon Lifecycle

| daemon | Start the Eww daemon                             |
| kill   | Kill the eww daemon                              |
| logs   | Print and watch the eww logs                     |
| ping   | Ping the eww server, checking if it is reachable |
| reload | Reload the configuration                         |

Misc

| help              | Print this message or the help of the given subcommand(s) |
| inspector         | Open the GTK debugger                                     |
| shell-completions | Generate a shell completion script                        |

+ eww open-many :: will be deprecated, rolled into =eww open=

*** Example Bar

#+begin_src yuck :tangle (format "%s/eww/%s" (getenv "XDG_CONFIG_HOME") "eww.yuck")
(defwidget bar []
  (centerbox :orientation "h"
    (workspaces)
    (music)
    (sidestuff)))

(defwidget sidestuff []
  (box :class "sidestuff" :orientation "h" :space-evenly false :halign "end"
    (metric :label "ðŸ”Š"
            :value volume
            :onchange "amixer -D pulse sset Master {}%")
    (metric :label "ï¡š"
            :value {EWW_RAM.used_mem_perc}
            :onchange "")
    (metric :label "ðŸ’¾"
            :value {round((1 - (EWW_DISK["/"].free / EWW_DISK["/"].total)) * 100, 0)}
            :onchange "")
    time))

(defwidget workspaces []
  (box :class "workspaces"
       :orientation "h"
       :space-evenly true
       :halign "start"
       :spacing 10
    (button :onclick "wmctrl -s 0" 1)
    (button :onclick "wmctrl -s 1" 2)
    (button :onclick "wmctrl -s 2" 3)
    (button :onclick "wmctrl -s 3" 4)
    (button :onclick "wmctrl -s 4" 5)
    (button :onclick "wmctrl -s 5" 6)
    (button :onclick "wmctrl -s 6" 7)
    (button :onclick "wmctrl -s 7" 8)
    (button :onclick "wmctrl -s 8" 9)))

(defwidget music []
  (box :class "music"
       :orientation "h"
       :space-evenly false
       :halign "center"
    {music != "" ? "ðŸŽµ${music}" : ""}))


(defwidget metric [label value onchange]
  (box :orientation "h"
       :class "metric"
       :space-evenly false
    (box :class "label" label)
    (scale :min 0
           :max 101
           :active {onchange != ""}
           :value value
           :onchange onchange)))

(deflisten music :initial ""
  "playerctl --follow metadata --format '{{ artist }} - {{ title }}' || true")

(defpoll volume :interval "1s"
  "printf '42'")

(defpoll time :interval "10s"
  "date '+%H:%M %b %d, %Y'")

(defwindow bar
  :monitor 0
  :windowtype "dock"
  :geometry (geometry :x "0%"
                      :y "0%"
                      :width "90%"
                      :height "10px"
                      :anchor "top center")
  :reserve (struts :side "top" :distance "4%")
  (bar))
#+end_src

SCSS

#+begin_src scss :tangle (format "%s/eww/%s" (getenv "XDG_CONFIG_HOME") "eww.scss")
// Emacs/Org: the asterisk in `* {}` needs to be escaped as `,* {}`
,* {
  all: unset; // Unsets everything so you can style everything from scratch
}

// Global Styles
.bar {
  background-color: #3a3a3a;
  color: #b0b4bc;
  padding: 10px;
}

// Styles on classes (see eww.yuck for more information)

.sidestuff slider {
  all: unset;
  color: #ffd5cd;
}

.metric scale trough highlight {
  all: unset;
  background-color: #D35D6E;
  color: #000000;
  border-radius: 10px;
}

.metric scale trough {
  all: unset;
  background-color: #4e4e4e;
  border-radius: 50px;
  min-height: 3px;
  min-width: 50px;
  margin-left: 10px;
  margin-right: 20px;
}

.label-ram {
  font-size: large;
}

.workspaces button:hover {
  color: #D35D6E;
}
#+end_src


