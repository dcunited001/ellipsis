#!/bin/sh

# TODO: support -- --passing --args to/gnupg

_print_usage() {
    echo "`basename $0` [+-o <output>] [+-r <recipient1>]  [+-R <recipient2>] <file>"
    echo
    echo "supports only one file for now."
    echo
    echo "  both recipient arguments will be passed to gpg via -r"
    echo
    echo "  recipient1: the recipient to which data is currently encrypted."
    echo "  recipient2: the new recipient, probably a subkey fingerprint."
    echo
    echo "use `-o -` to write to STDOUT."
    echo
    echo "  if output is omitted, command writes to STDOUT."
    echo "  if output is a directory, recrypted content will be saved as $output/$file"
    echo
}

recip1=
recip2=
output=-
# output_is_dir=

while getopts :o:r:R: OPT; do
    case $OPT in
        o|+o)
            output="$OPTARG"
            ;;
        r|+r)
            recip1="$OPTARG"
            ;;
        R|+R)
            recip2="$OPTARG"
            ;;
        --)
            break
            ;;
        *)
            _print_usage
            exit 2
    esac
done

shift `expr $OPTIND - 1`
OPTIND=1

input=$1

# for now, just mandate both recipients (maybe later: infer first)
if [ -z "$recip1" ] || [ -z "$recip2" ]; then
    _print_usage
    echo
    echo "Recipients are required"
    exit 2
fi

if [ -d "$output" ]; then
    gpg -r $recip1 -d $file | gpg -r $recip2 -e
else
    gpg -r $recip1 -d $file |
fi

# gpg -r "David Conner <aionfork@gmail.com>"
#     -d ~/.env/aionfork.authinfo.gpg  |
# gpg -r "5AA3269777368E0F" -e --armor

echo $output $recip1 $recip2
