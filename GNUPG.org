#+title: GnuPG Configuration
#+description:
#+startup: content
#+property: header-args            :tangle-mode (identity #o400) :mkdirp yes
#+property: header-args:conf       :tangle-mode (identity #o400) :mkdirp yes
#+property: header-args:sh         :tangle-mode (identity #o500) :mkdirp yes
#+property: header-args:bash       :tangle-mode (identity #o500) :mkdirp yes
#+property: header-args:scheme     :tangle-mode (identity #o700) :mkdirp yes
#+property: header-args:emacs-lisp :tangle-mode (identity #o600) :mkdirp yes
#+options: toc:nil

* Resources

** GPG

*** Configuration

+ [[https://github.com/drduh/config/blob/master/gpg.conf][drduh/config]] gpg.conf
+ [[https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html][GPG Config Options]] (docs)
+ [[https://www.gnupg.org/documentation/manuals/gnupg/GPG-Esoteric-Options.html][GPG Esoteric Options]] (docs)

*** Source [[https://git.gnupg.org/cgi-bin/gitweb.cgi][git.gnupg.org]]

[[https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob;f=agent/keyformat.txt;hb=HEAD][keyformat.txt]] the format of S-expressions in private keys. It answers all your
questions about life, about the eternal mysteries and about what should be
frequently mentioned by developers online ... but is not.

**** Issues [[https://dev.gnupg.org][dev.gnupg.org]]

*** Using multiple yubikeys

GnuPG will default to using the most recent key for keysigning operations.

#+begin_quote
So just because the filesize doubles when you update your keyring with the
=rsa4096= subkeys that you forgot doesnt mean that it's signing with both
keys. The filesize is actually larger because GPG defaults to the newest public
subkeys and RSA sucks so the files are larger.
#+end_quote

[[https://blogs.gentoo.org/mgorny/2018/05/12/on-openpgp-gnupg-key-management/][Leave it to the Gentoo guys]] to answer your questions. You can use multiple
yubikeys, but only use one set of subkeys.

** GPG Agent

See [[https://www.gnupg.org/documentation/manuals/gnupg/Agent-Protocol.html][Agent ASSUAN protocol]] for other things like:

#+begin_example shell
gpg-connect-agent updatestartuptty /bye > /dev/null
#+end_example

Commands need to be enclosed in quotes:

#+begin_example shell
gpg-connect-agent "help getinfo"
#+end_example

Getting a REPL with =gpg-connect-agent= allows =help [cmd]=

And, =/if= you want GPG problems at scale, =/then= you can write scripts. I'm
just curious about questions that are hard to see, like SSH =ControlMaster=.

Getting leads on the above was actually pretty difficult ([[https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob;f=agent/command.c;h=9481f47c3ec0b19af47a4db96b866e1928292caf;hb=HEAD#l3760][./agent/commands.c]]) I
guess since no one customizes anything and the GUI does most of it for them.

** Crypto
+ [[https://developers.redhat.com/blog/2017/10/05/entropy-rhel-based-cloud-instances#][Entropy in RHEL-based cloud instances]]
+ [[https://www.random.org/randomness/][Introduction to Randomness and Random Numbers]]

** GPG Integration
+ [[https://alexschroeder.ch/cgit/ugg/about/][The Using GPG Guide]]
+ [[https://git.vdm.dev/knowledge/YubiKey-Guide][VDM Yubikey-Guide]]
+ [[https://github.com/drduh/YubiKey-Guide][drduh/YubiKey-Guide]]

*** Emacs
+ [[https://www.gnu.org/software/emacs/manual/html_mono/auth.html][auth-source]]

Emacs Wiki ([[https://www.emacswiki.org/emacs/Using_GPG][GPG topic]])

+ [[https://www.emacswiki.org/emacs/Gmail%2c_Gnus_and_GPG][Gmail, Gnus and GPG]]
+ [[https://www.emacswiki.org/emacs/GnuPG][Gnu PG]]
+ [[https://www.emacswiki.org/emacs/AutoEncryption][Auto Encryption]]

Mastering Emacs

+ [[https://www.masteringemacs.org/article/keeping-secrets-in-emacs-gnupg-auth-sources][Keeping Secrets in Emacs with GnuPG and Auth Sources]]

*** Forwarding
+ [[https://rabbithole.wwwdotorg.org/2021/03/03/gpg-agent-fwding-over-ssh.html][GPG Agent Forwarding via SSH]]

*** Thunderbird
+ [[https://support.mozilla.org/en-US/kb/openpgp-thunderbird-howto-and-faq][OpenPGP in Thunderbird: How To and FAQ]]
+ [[https://wiki.mozilla.org/Thunderbird:OpenPGP:Smartcards][Thunderbird, OpenPGP and Smartcards]]

*** KDE
+ [[https://ebzzry.com/en/gsk/][Setting up GPG and SSH in KDE]]

*** Scripting
+ The s/o answers for [[https://unix.stackexchange.com/questions/60213/gpg-asks-for-password-even-with-passphrase][gpg asks for password even with --passphrase]] describe
  using =--batch --passphrase-fd= to get a passphrase from a file descriptor
  =<(pass --command)=

* GPG Environment

The table approach in [[file:ANSIBLE.org][ANSIBLE.org]] is a bit confusing. This is more verbose, yet
more direct. It involves less metaprogramming.

#+begin_src emacs-lisp :eval no :tangle no
(setenv "SECRETS_HOME" ".gnupg.test")
#+end_src

#+name: secretshome
#+begin_src emacs-lisp
(or (getenv "SECRETS_HOME") ".")
#+end_src

** GPG TTY

For the programs that need to have GPG access, I will configure things like
=GPG_TTY= in the startup script or in the flatpak overrides. I really just don't
trust X11, not that Wayland is much better since it invites an XWayland
dependency for everything.

** Pinentry

#+name: gpgpinentry
#+begin_src emacs-lisp :tangle no
"pinentry-curses"
#+end_src

#+RESULTS: gpgpinentry
: pinentry-curses

** Personal Keys

Change these to the fingerprints of your personal keys

#+name: gpgmaster
#+begin_src shell
"0x9FCE9B3064CED760"
#+end_src

#+RESULTS: gpgmaster
: 9FCE9B3064CED760

#+name: gpgsign
#+begin_src shell
"0xB5E0535B23DD6A7A"
#+end_src

#+RESULTS: gpgsign
: B5E0535B23DD6A7A

#+name: gpgcrypt
#+begin_src shell
"0x5AA3269777368E0F"
#+end_src

#+RESULTS: gpgcrypt
: 5AA3269777368E0F

#+name: gpgauth
#+begin_src shell
"0xFC275EE2A3547885"
#+end_src

#+RESULTS: gpgauth
: FC275EE2A3547885

#+begin_src shell :noweb-ref gpgring :noweb yes :noweb-sep ""
export PINENTRY=<<gpgpinentry>>
export GPGMASTER=<<gpgmaster>>
export GPGSIGN=<<gpgsign>>
export GPGCRYPT=<<gpgcrypt>>
export GPGAUTH=<<gpgauth>>
#+end_src

#+RESULTS:

** Guix Profile

The Guix profile will need to be installed. Unless =GNUPG_PATH= is set when
=init-gpg.sh= is sourced, then the profile is expected to be installed to
=$GUIX_EXTRA/gpgagent/gpgagent=

It makes more sense to do this in a manifest than to add a custom package to a
guix channel. Thankfully the guix transformations are very flexible. See =guix
shell --help-transform= for more information.

#+begin_src scheme :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.config/guix/manifests/gpgagent.scm")
(use-modules (guix packages)
             (guix transformations)
             (guix download)
             (guix git-download)
             (gnu packages base)
             (gnu packages guile)
             (gnu packages gnupg)

             (gnu packages autotools)
             (gnu packages pkg-config)

             (gnu packages password-utils))

;; The project only builds in xclip behavior
;; if it finds the dependencies. it's
;; much smaller without them.
(define-public shroud-nox
  (package
    (inherit shroud)
    (name "shroud-nox")
    (version "0f5a58da63cacce3bb839427fd1d87c9230800ad")
    (source (origin
              (method git-fetch)
              (uri (git-reference
                    (url "https://git.dthompson.us/shroud.git")
                    (commit version)))
              (sha256
               (base32
                "0xn916i8ma9xinavq9avfi4rg9770c0hzimbwglqq1slfwa8c3nq"))
              (file-name (git-file-name name version))))
    (inputs
     (list guile-2.2 gnupg))

    (native-inputs
     (list pkg-config autoconf automake))))

;; needs to build from master to set alternate config/db
(define shroud-master
  (options->transformation
   '((with-branch . "shroud=master"))))

(packages->manifest
 (list gnupg
       pinentry-tty
       shroud-nox))
#+end_src

**** TODO include SSH/opensc in the profile?
or use separate guix profiles? (on either USB or the system)

** Portable GPG

Honestly, using =guix pack= to create a portable guix profile wasn't beneficial
enough to offset the complexity.  A portible profile is arguably more useful for
Ansible -- especially for hackers operating behind enemy lines, lol -- so I
moved any notes to [[file:ANSIBLE.org::*Guix Profile][ANSIBLE.org.]]

#+begin_quote
Firewalling SSH? oh noes: on what port?

lol i hope you have deep-packet inspection.
#+end_quote

* Init Script

#+begin_src shell :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.gnupg/init-gpg.sh") :shebang "#!/bin/sh" :tangle-mode (identity #o500) :noweb yes
<<gpgring>>
#+end_src

If =SECRETS_HOME= is not set, it's set to =$(pwd)=. Do this before sourcing
=init-gpg.sh=. Another option is to link =$HOME/.gnupg= to
=$SECRETS_HOME/.gnupg= and then you can source the script in a fresh shell.

#+begin_src shell :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.gnupg/init-gpg.sh") :tangle-mode (identity #o500)
if [ -z $SECRETS_HOME ];then
    export SECRETS_HOME="$(pwd)"
    echo "SECRETS_HOME=$SECRETS_HOME"
fi

# if not using on a system where $GNUPGHOME == $SECRETS_HOME/.gnupg
# then make it so before sourcing the script
if [ -z $GNUPGHOME ];then
    export GNUPGHOME=$HOME/.gnupg
    echo "GNUPGHOME=$GNUPGHOME"
fi
export PATH=$SECRETS_HOME/.bin:$PATH

# unless there is a specific $GNUPG_PATH, use a guix profile
if [ -z $GNUPG_PATH ];then
    # then load GnuPG profile
    GUIX_EXTRA=$HOME/.guix-extra-profiles
    GUIX_PROFILE=$GUIX_GNUPG_PROFILE
    if [ -z $GUIX_PROFILE ];then
        GUIX_PROFILE=$GUIX_EXTRA/gpgagent/gpgagent
    fi
    source $GUIX_PROFILE/etc/profile
    GNUPG_PATH=$GUIX_PROFILE/bin
fi

# GPG Agent
# see below for startup scripts

# SSH Agent
# should be disabled

# Shroud Database
export SHROUD_CONFIG_FILE=$SECRETS_HOME/.shroud
export SHROUD_DATABASE_FILE=$SECRETS_HOME/.config/shroud/db.gpg
#+end_src

** SSH Agent (via GPG)

*** Notes

+ Using SSH via GnuPG
  - =/bye= redirects SSH calls to its socket to the GnuPG embedded SSH agent

+ The list of approved keys is stored in =~/.gnupg/sshcontrol=

+ If you use a PGP key for SSH auth (requires =Authentication= capability)
  - check for the key (when s/card is loaded) by listing keys or
    checking fingerprints: =ssh-add -l/L=
  - if the GPG is not on a s/card, then add the keygrip to =~/.gpg/sshcontrol=

This would cause GnuPG daemon's =GPG_TTY= variable to be updated on
every SSH command invocation: but allows you to enter the pin from the
same terminal you are ssh-connecting through. 

#+begin_src conf
Match host * exec "gpg-connect-agent UPDATESTARTUPTTY /bye"
#+end_src

** GPG Agent

*** Start


To start GPG Agent, source the above =init-gpg.sh= script, then run =start-gpg=
or =start-gpg-connect=. My notes say to prefer starting =gpg-agent= via
=gpg-conf= but I honestly can't remember why.

**** With =gpg-connect-agent=

#+begin_src shell :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.bin/start-gpg-connect") :shebang "#!/bin/sh" :tangle-mode (identity #o500)
export GPG_TTY="$(tty)"
unset SSH_AGENT_PID
export SSH_AUTH_SOCK="/run/user/$UID/gnupg/S.gpg-agent.ssh"
gpg-connect-agent update-startuptty /bye > /dev/null
#+end_src

**** With =gpgconf=

Prefer to start with =gpgconf=

#+begin_src shell :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.bin/start-gpg") :shebang "#!/bin/sh" :tangle-mode (identity #o500)
export GPG_TTY="$(tty)"
unset SSH_AGENT_PID
export SSH_AUTH_SOCK="$(gpgconf --list-dirs agent-ssh-socket)"
gpgconf --launch gpg-agent
#+end_src

**** Without =ssh=

***** TODO init script without ssh

*** Application Integration

For any given appliation, either its launch scripts or the window manager's
shell should have =GPG_TTY= set. Obviously, the whole point of doing things this
way is so applciations in X11 have minimal awareness of GPG -- this is me being
paranoid, but honestly, it's crazy to think that it's done that way. Of course,
smartcards improve the potential for X11 keylogging.

For flatpak apps:

+ Link =$HOME/.gnupg= to =$SECRETS_HOME/.gnupg=
+ Run =flatpak --env=GPG_TTY=/dev/ttyX org.mozilla.Thunderbird=. This can also
  be included in a script, called after =GPG_TTY= has been established for the
  =gpg-agent=.

#+begin_src shell :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.bin/flatpak-gpg-overrides") :shebang "#!/bin/sh" :tangle-mode (identity #o500)
flatpak --user override --env=GPG_TTY=$(tty) org.mozilla.Thunderbird
#+end_src

This apparently works alright, though I needed to paste in the public key to
circumvent the flatpak restrictions on file access.

[[./img/thunderbird-signed.jpg]]

** Shell Examples

Cut the keys out of the =gpg -k= output.

#+begin_example shell
gpg -k | grep -e "^sub" | cut -b 16-33
#+end_example

Get the environment variables that =gpg= passes to =gpg-agent=. These are the
only variables permitted in =gpg-agent.conf=.

#+begin_src shell :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.bin/gpg-agent-env") :shebang "#!/bin/sh" :tangle-mode (identity #o500)
gpg-connect-agent 'getinfo std_env_names' /bye | awk '$1=="D" {print $2}'
#+end_src

Troubleshoot =gpg-agent=

#+begin_src shell :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.bin/start-gpg-debug") :shebang "#!/bin/sh" :tangle-mode (identity #o500)
export GPG_TTY="$(tty)"
unset SSH_AGENT_PID
export SSH_AUTH_SOCK="$(gpgconf --list-dirs agent-ssh-socket)"
gpg-agent --daemon --no-detach -v -v --debug-level advanced
#+end_src

Troubleshoot =gpg-agent= with:

+ =--debug-pinentry=
+ =--debug 1024= which is required

#+begin_src shell :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.bin/start-gpg-debug-pinentry") :shebang "#!/bin/sh" :tangle-mode (identity #o500)
export GPG_TTY="$(tty)"
unset SSH_AGENT_PID
export SSH_AUTH_SOCK="$(gpgconf --list-dirs agent-ssh-socket)"
gpg-agent --daemon --no-detach -v -v --debug-pinentry --debug 1024
#+end_src

* GPG

** GPG Config

*** Defaults

#+begin_src conf :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.gnupg/gpg.conf.defaults")
# Use AES256, 192, or 128 as cipher
personal-cipher-preferences AES256 AES192 AES

# Use SHA512, 384, or 256 as digest
personal-digest-preferences SHA512 SHA384 SHA256

# Use ZLIB, BZIP2, ZIP, or no compression
personal-compress-preferences ZLIB BZIP2 ZIP Uncompressed

# Default preferences for new keys
default-preference-list SHA512 SHA384 SHA256 AES256 AES192 AES ZLIB BZIP2 ZIP Uncompressed

# SHA512 as digest to sign keys
cert-digest-algo SHA512

# SHA512 as digest for symmetric ops
s2k-digest-algo SHA512

# AES256 as cipher for symmetric ops
s2k-cipher-algo AES256

# UTF-8 support for compatibility
charset utf-8

# Show Unix timestamps
fixed-list-mode

# No comments in signature
no-comments

# No version in output
no-emit-version

# Disable banner
no-greeting

# Long hexidecimal key format
keyid-format 0xlong

# Display UID validity
list-options show-uid-validity
verify-options show-uid-validity

# Display all keys and their fingerprints
with-fingerprint

# Display key origins and updates
#with-key-origin

# Cross-certify subkeys are present and valid
require-cross-certification

# Disable caching of passphrase for symmetrical ops
no-symkey-cache

# Enable smartcard
use-agent

# Disable recipient key ID in messages
throw-keyids

# Default/trusted key ID to use (helpful with throw-keyids)
#default-key 0xFF3E7D88647EBCDB
#trusted-key 0xFF3E7D88647EBCDB

# Group recipient keys (preferred ID last)
#group keygroup = 0xFF00000000000001 0xFF00000000000002 0xFF3E7D88647EBCDB

# Keyserver URL
#keyserver hkps://keys.openpgp.org
#keyserver hkps://keyserver.ubuntu.com:443
#keyserver hkps://hkps.pool.sks-keyservers.net
#keyserver hkps://pgp.ocf.berkeley.edu

# Proxy to use for keyservers
#keyserver-options http-proxy=http://127.0.0.1:8118
#keyserver-options http-proxy=socks5-hostname://127.0.0.1:9050

# Verbose output
#verbose

# Show expired subkeys
#list-options show-unusable-subkeys
#+end_src

** Agent Config

*** Defaults

#+begin_src conf :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.gnupg/gpg-agent.conf.defaults")
# https://github.com/drduh/config/blob/master/gpg-agent.conf
# https://www.gnupg.org/documentation/manuals/gnupg/Agent-Options.html
enable-ssh-support
ttyname $GPG_TTY
allow-preset-passphrase

# Yubikey PIN is cached by the yubikey itself
# - these options don't affect it. you must unplug the key.
default-cache-ttl 60
max-cache-ttl 120

# pinentry-program must be set or gpg-agent expects an X11 compatible one
pinentry-program /usr/bin/pinentry-tty
#pinentry-program /usr/bin/pinentry-curses
#pinentry-program /usr/bin/pinentry-tty
#pinentry-program /usr/bin/pinentry-gtk-2
#pinentry-program /usr/bin/pinentry-x11
#pinentry-program /usr/bin/pinentry-qt
#pinentry-program /usr/local/bin/pinentry-curses
#pinentry-program /usr/local/bin/pinentry-mac
#pinentry-program /opt/homebrew/bin/pinentry-mac
#+end_src

** SCDaemon Config

The daemon is failing when =pcscd= and =scdaemon= already have a connection to
the Yubikey for the PIV/SSH application. (TODO: verify that this is the problem)

The =shared-access= option is dangerous according to the =scdaemon= manpages,
since the process caches information from the card.

#+begin_src conf :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.gnupg/scdaemon.conf.defaults")
reader-port Yubico Yubi
# shared-access
#+end_src

** SSH Control

Running =ssh-add= while GPG is running as an =ssh-agent= will:

- Prompt for the ssh key passphrase, decrypt it, and test for vaildity.
- Ask for a new passphrase. You could simply use the same passphrase ... but you
  do need one.
- The SSH key's keygrip is added into the =$GNUPGHOME/sshcontrol= file.
- It then stores the SSH key into the GPG private key format into
  =$GNUPGHOME=.

Without a passphrase, it's essentially unprotected as a string of octal
characters. It was pretty difficult to find a definitive answer on this.  People
will tell you to enter one, but I was kinda hoping it would be encrypted by the
GPG auth or encryption subkey.

The  [[https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob;f=agent/keyformat.txt;hb=HEAD][keyformat]] is described here.

Also, the =sshcontrol= file can be edited to add a priority to SSH keys, so when
SSH's post-modern interpretation of your =ssh_config= ignores things like
=IdentitiesOnly=, you may not be able to prevent it from doing that, but you can
make it try your keys in a specific order ...

** Managing SSH Key Passphrases

Anything that can send =stdout= to some command's =stdin= can be used to
retrieve passphrases without creating shell history, which is about as
sufficient as I can imagine at this level...

... nevermind, you need to use =<<<= or =<<HEREDOC= to avoid echoing the
passphrase in the process list, according to [[https://unix.stackexchange.com/questions/317298/what-are-the-steps-needed-to-cache-passphrases-entered-via-pinentry-using-gpg-pr][this s/o]]

Shroud is configured below for this purpose.

*** Testing SSH Keys

#+begin_src

#+end_src

** Interacting with Yubikey PIV module from =gpg-agent=

Oh, and there /IS/ a way to get GPG's =ssh-agent= emulation to interact with the
Yubikey =PIV= application ... so maybe learning all about that wasn't a complete
waste of time?

The =keyformat.txt= file indicates that the =Scute= module will handle this, but
I still need to look into it.

* Shroud

This is a password/secrets management tool. In the =gnupg-agent.scm=
profile, =shroud-nox= references a package in [[https://github.com/dcunited001/ellipsis/blob/master/ellipsis/packages/password-utils.scm][dcunited001/ellipsis]],
which is not [yet?] a channel.

For this kind of secrets management, shroud is a good choice:

+ Minimal dependencies: guile scheme, gpg
+ GPG integration: and this means smartcard integration.
+ In memory: GPG means the secrets are pulled into RAM and then gone.

Alternatives considered:

+ tomb :: This is a nice one, but requires zsh. I don't fully trust
  zsh and would prefer to avoid the dependency.
+ pwsafe :: I couldn't find a Guix package without X11/GTK
  dependencies. There are several packages, but it's a bit confusing.
+ file-system-based tools :: LUKS is secure ... until you mount
  it. Other tools like truecrypt/veracrypt/fscrypt are similar. I
  don't want to have to trust even my own user. If it is mounted as a
  file-system, then other processes can impersonate my user and access
  the data.
  - with GPG-based tools, if my yubikey is required, then it is much
    more difficult for processes to impersonate authorization.

** Config

The environment variables configured in =init-gpg.sh= require the master branch
of shroud. The defaults are below:

+ SHROUD_CONFIG_FILE :: ~/.shroud
+ SHROUD_DB_HOME :: ~/.config/shroud/db.gpg

 Write the list of identities to =.shroud=

#+begin_src scheme :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.shroud.defaults")
'((user-id . "myemail@fdsa.com"))
#+end_src

The keys are stored in a fairly plain scheme dictionary. It can be opened in
vanilla emacs and edited as plain text, so long as emacs knows out to reach its
=gpg-agent= socket.

Password files cannot easily be diffed. Since this is a plain dictionary and you
have a reasonable programming language, then it's significantly easier to merge
changes from multiple copies of password files on various hosts ... without the
cloud.

#+begin_example scheme
(((id . "id3nt") (contents ("asdf" . "asdf")
                           ("abcd" . "asdf")
                           ("fdsa" . "jhkl"))))
#+end_example

You can add keys and values from the command line:

#+begin_example shell
shroud hide $identity $key=$value
#+end_example

And you can retrieve multiple keys from the dictionary. If they don't exist,
nothing is returned.

#+begin_src shell
shroud show $identity # to show them all
shroud show $identity | cut -f1 # to cut all the
shroud show $identity "ssh123" # to select the passphrase
#+end_src

To pipe them into SSH or GPG operations, you may need to use file descriptors
depending on how the commands handle =stdout= or =stdin=

#+begin_src
shroud show $identity "ssh123" | gpg
#+end_src

References to these file descriptors can be stored in Bash, but if they are more
than ephemeral ... something somewhere may also have permissions to read from
them, so prefer anonymous FD's.

** Storing passphrases

Get the fingerprint with

#+begin_src shell :eval no
pubkey=~/.ssh/key.pub
pubkey_fpr="$(ssh-keygen -lf $pubkey -E sha256 | cut -f2 -d' ')"
identity=me@me.com
#+end_src

Store the passphrase with =read -r=

#+begin_src shell :eval no
read -r passphrase
shroud hide $identity $pubkey_fpr=$passphrase
#+end_src

Or store a random passphrase:

#+begin_src shell :eval no
pplength=12
shroud hide $identity $pubkey_fpr=$(gpg --gen-random --armor 0 16 | cut -b$pplength)
#+end_src

It's also totally possible to just edit the file in emacs using =C-u C-M-!= to
insert the output off commands.

Add to GPG with:

#+begin_src shell :eval no
# ok ssh-add only accepts passwords from the program set as the SSH_ASKPASS variable
# but this does not work when managed by gpg-agent
#+end_src

Unlock in GPG with:

#+begin_src

#+end_src

*** Select keygrip from GPG

#+begin_src shell
keyfile=~/.ssh/key
pubfile=$keyfile.pub
keysha=$(ssh-keygen -E sha256 -lf $pubfile | cut -f2 -d' ')
keygrip=$(gpg-connect-agent "KEYINFO --ssh-list --ssh-fpr=sha256" /bye | \
              head -n-1 | grep $keysha | cut -f3 -d' ')
#+end_src

*** Preset Passphrase in GPG

Here's what =preset_passphrase= does:

#+begin_src shell :output verbatim
gpg-connect-agent "help preset_passphrase" /bye | head -n-1
#+end_src

#+RESULTS:
: # PRESET_PASSPHRASE [--inquire] <string_or_keygrip> <timeout> [<hexstring>]
: #
: # Set the cached passphrase/PIN for the key identified by the keygrip
: # to passwd for the given time, where -1 means infinite and 0 means
: # the default (currently only a timeout of -1 is allowed, which means
: # to never expire it).  If passwd is not provided, ask for it via the
: # pinentry module unless --inquire is passed in which case the passphrase
: # is retrieved from the client via a server inquire.

I think the =gpg-preset-passphrase= tool is required for this to work, but the
executable is missing for me on both arch & guix.

#+begin_src shell :eval no

#+end_src

Otherwise, this should work, but is still returning =Err 67108933 not implemented <GPG Agent>=:

#+begin_src shell :eval no
# get $keygrip
shroudpass=$(shroud show $identity $keysha)
gpg-connect-agent "preset_passphrase $keygrip 0 $shroudpass" /bye
#+end_src

*** To Delete SSH Keys from GPG

Find the SSH key:

#+begin_src shell :eval no
# get $keygrip
gpg-connect-agent "DELETE_KEY $keygrip" /bye

# or rm ~/.gnupg/private-keys-v1.d/$keygrip.key
#+end_src

* Emacs

** Loading the profile

Either Link =~/.emacs.d= to =$SECRETS_HOME= or, using chemacs, run:

#+begin_src shell :eval no
emacs --with-profile '((user-emacs-directory . (getenv "SECRETS_HOME")))'
#+end_src

** Guix packages:

**** TODO setup a portable emacs profile

Which will be of limited utility if: any bin tools or path deps don't work/interact properly on the system

** Babel

The essentials

#+begin_src emacs-lisp :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.emacs.d/init.el")
(setq org-directory "~/org"
      org-adapt-indentation nil
      org-src-preserve-indentation t)

(defun read-only-when-pgp ()
  (when (and (fboundp #'buffer-file-name)
             (buffer-file-name)
             (string-match "\\.key$" (buffer-file-name)))
    (read-only-mode)))

(add-to-list 'after-change-major-mode-hook #'read-only-when-pgp t)
#+end_src

And if you want lispy to be configured:

#+begin_example emacs-lisp
(when (bound-and-true-p lispy-mode)
  (cl-dolist (hook '(scheme-mode-hook
                     emacs-lisp-mode-hook
                     lisp-data-mode-hook
                     ielm-add))
    (add-hook hook #'lispy-mode)))

(advice-add 'lispy-goto-symbol-elisp :override #'xref-find-definitions '(name "dc/nanon"))
#+end_example

** Tangling

*** File Ownership/Permissions

I couldn't find options to specify file owner/group when tangling
files. The permissions of these files are critical. GPG/Agent and SSH
will refuse to function if the permissions are not set correctly. When
the permissions are not in =400,600,700=, then the group should
probably be set to =wheel=.

* Entropy

I don't know what I'm doing, so you've been warned lol. It generates keys very
fast though, so I guess it works?

** Add an entropy source

Use [[Entropy s][Yubikey as entropy source]]. GPG agent should already be running.

Create a new cert in slot 9a (this will replace the existing 9a PIV cert!)

#+begin_src shell :eval no
ykman piv keys generate --algorithm ECCP256 9a pubkey.pem
#+end_src

Run =rngd= in background using Yubikey as =/dev/random= source:

#+begin_src shell :eval no
rngd -x hwrng -x tpm -x rdrand -x jitter -n pkcs11 -b -W 4096 -f
#+end_src

Options:

+ -x :: disables an existing rng source. =rngd -l= to list
+ -n pkcs11 :: specifiy the pkcs11 source
+ -b :: run =rngd= in the background
+ -W 4096 :: specify the intended entropy size
+ -f :: keep running even when full

**** TODO verify whether =-o /tmp/yubirng= as output is required

** Test with =rngtest=

Compare lines with =FIPS 140-2 successes/failures=. It should be very close to 100%.

#+begin_src shell :eval no
cat /dev/random | rngtest -c 1000
#+end_src

* Backups

You should never have an active/connected network device when working with these
file systems. The system should have been booted offline and have remained
offline the entire time. It should never connect to the network before being
reset. Ideally, it should be a system that has no disks other than what is
necessary.

The goal is to get the keys onto the yubikey where they are safe. They can also be generated on the yubikey itself.

** Digital

Flash storaget is thought to become less reliable with time if its CMOS is not powered (i.e. if you don't plug it in for long periods of time)

*** Test the flash storage with F3

F3 isn't really a comprehensive test, but this will help you preempt problems with counterfeit flash storage. It will mainly tell you if there are bad sectors where =f3brew= wrote data, but could not read it.

=f3brew= will destructively write to the entire disk!

#+begin_src shell :eval no
f3brew /dev/sdX
#+end_src

This will take a long time. It will prompt you to disconnect/reconnect the storage device. At the end, it will tell you, in hex, how much data was written.

*** Provision the flash partitions for RAID -1

Calculate the partition sizes. Check the number of sectors =n=.

#+begin_src shell :eval no
LC_ALL=C fdisk -l /dev/sdX
#+end_src

Take =m = (n/4) % 2048=, since =cfdisk= will round partition sizes down to the nearest multiple of =2048=

Use =cfdisk= to test the partition sizes. You should end up with four. Ensure that the partition sizes, to the sector, are identical.

#+begin_src shell :eval no
cfdisk -z /dev/sdX
#+end_src

Just create the partitions. Use =mkfs.ext2= to format them later.

*** Create a partition and backup the files

Format the first partition with =mkfs.ext2=.

#+begin_src shell :eval no
mkfs.ext2 /dev/sdX1 -L gpg-$(date +%F)
#+end_src

For further data redundancy, you can use btrfs which can totally duplicate its data and metadata. This will reduce the total disk size by +50%.

#+begin_src shell :eval no
mkfs.btrfs -L gpg-$(date +%F) -d dup -m dup
#+end_src

When mounting, you should ensure =readonly= and =noatime= are consistently
applied to prevent unintentional mutation of the data, which will keep the disk copies in sync unless they are intentionally modified.

#+begin_src shell :eval no
cryptsetup luksOpen /dev/sdXn backupn
mount -r -o noatime /dev/mapper/backupn /mnt/backupn -o noatime
#+end_src

*** Duplicate the partitions

View the partitions with =lsblk= and copy the images from =/dev/sdX1= to =/dev/sdX2= and =/dev/sdY1= and so forth.

#+begin_src shell :eval no
# i'm not sure whether bs=1M will affect the block structure of the disk
dd if=/dev/sdX1 of=/dev/sdX2 status=progress
#+end_src

This will not affect the partition labels which exist inside the LUKS volumes.
If you want to mount them with the labels, then change with with =e2label
/dev/sdXn newLabel= while the LUKS volume is open.

*** Close the luks device

Since the partition is not inside an LVM2 volume, you can simply use =dmsetup info= to query the block device mappings to find the name and:

#+begin_src shell :eval no
umount /mnt/backupn
cryptsetup luksClose backupn
#+end_src

Working with multiple identical partitions is a bit tricky, esp. when they do
contain LVM2 volumes. At any point, you should not attempt to mount devices with
the same LUKS block device ID's or PV/LV ID's. Ensure that they are completely
unmounted with =dmsetup info= et alias.

** Paperkey

Paperkey is included on the image and will export the password-protected GPG
keys to a txt file, which you can print. If unlike me you have more than a 5
digit salary and you print them out, they can be placed in a safety deposit box.

This gives you an option to generate new keys and issue/use revocation certs, in
case the backup is lost.

*** Backup

Export an unarmored copy of the master secret to a secure disk.

#+begin_src shell :eval no
gpg --export-secret-keys $KEYID > $GNUPGHOME/mastersub.unarmored.key
paperkey --secret-key .gnupg/mastersub.unarmored.key --output mastersub.paperkey.txt
#+end_src

Print it and then clear your printer's internal cache...

* Scripting

#+begin_src emacs-lisp

#+end_src

** Utility Functions

hmmmm ... =almost-surely-most-positive-fixnum=?

#+begin_src emacs-lisp
(format "%X" (* 1 most-positive-fixnum))         ;"1FFFFFFFFFFFFFFF"
(format "%X" (* 2 most-positive-fixnum))         ;"3FFFFFFFFFFFFFFE"
(format "%X" (* 4 most-positive-fixnum))         ;"7FFFFFFFFFFFFFFC"
(format "%X" (* 8 most-positive-fixnum))         ;"FFFFFFFFFFFFFFF8"
(format "%X" (* 16 most-positive-fixnum))       ;"1FFFFFFFFFFFFFFF0"
(format "%X" (+ 1 (* 16 most-positive-fixnum))) ;"1FFFFFFFFFFFFFFF1"
#+end_src

Well =integer-width= is set to =65536=. That's interesting.

Generate octal or other formats

#+begin_src emacs-lisp
(defun rand-formatted (format &optional nchars)
  (if-let* ((nbits (or (and (equal format "o") 3)
                       (and (equal format "X") 4)))
            (nmax (or (and nchars
                           (expt 2 (* nbits nchars)))
                      (* 2 most-positive-fixnum)))
            (nrand (random nmax)))
      (progn
        (message "%s %s %s" nbits nmax nrand)
        ;; nrand
        (format (concat "%" format) nrand))
    (user-error "something not right")))
#+end_src

Generate MD5 Hex

#+begin_src emacs-lisp
(let* ((hash-str (reverse "fdab123ce"))
       (nchars (length hash-string)))
  (cl-loop for i from 1 to (- (length hash-str) 1)
           iter-by 2
           thereis (< (- nchars i) 2)
           collect))
#+end_src

#+RESULTS:

 ... or not

#+begin_quote
i could write this in clojure in like 5 seconds ... does cl-reduce give you the
index? well it doesn't allow you to really accumulate.
#+end_quote

So =hexdump= it is ... i forgot about that and didn't realize it has plenty of
[[https://stackoverflow.com/questions/34328759/how-to-get-a-random-string-of-32-hexadecimal-digits-through-command-line][formatting options]]. Thanks command line.

#+begin_src shell :results verbatim
bytes=32
chunk_bytes=2
chunks="$(($bytes/$chunk_bytes))"

# for hex, luckily octal doesn't need to be interpolated
hd_hex_formatter="%0$((2 * chunk_bytes))X"
hd_expr="$((chunks - 1))/$chunk_bytes \"$hd_hex_formatter:\""
hd_expr="$hd_expr 1/$chunk_bytes \"$hd_hex_formatter \n\""

echo $hd_expr
hexdump -vn"$bytes" -e "$hd_expr" /dev/urandom
#+end_src

#+RESULTS:
: 15/2 "%04X:" 1/2 "%04X \n"
: 693A:02C4:757A:2E97:6D02:0DA2:BCBD:0332:0D32:681A:5677:19B8:173B:4F1E:27F9:2D53

** Join Across Command Output

Unfortunately the =join= command only allows one input to be piped in. So
=mktemp -d= can be used to get around that, but this probably shouldn't be
used. Still I haven't gotten much practice with these commands or file
descriptors, so I'd like to document using them for my own purposes...

The =gpg-connect-agent= command =KEYINFO=  outputs in this format:

=KEYINFO <keygrip> <type> <serialno> <idstr> <cached> <protection> <fpr>=

The =ssh-add -l -E MD5= command outputs in this format

=<algorithm> MD5:<ssh-frg> <key comment>= or =ssh-add -l= outputs with =SHA256=

So we can guarantee spacing of fields and join against them, the goal being to
guarantee the uniqueness of a key's fingerprint.

#+begin_src shell

gpg-connect-agent "KEYINFO --ssh-list --ssh-fpr" /bye | \
    head -n-1 | \

#+end_src

**** TODO complete join example

** Select with md5 instead

(incomplete)

#+begin_src shell :eval no
regexMD5='MD5:([[:xdigit:]:]+)'

gpg-connect-agent "KEYINFO --ssh-list --ssh-fpr" /bye | \
    head -n-1 | \
    sed -E "s/^.*$regexMD5.*$/\1/g" \

# either named or nested captures don't seem to work...
#    sed -e 's/^.*MD5\(?<fgr>\(:[0-9a-f]\{2\}\)\)/\k<fgr>/'
#    sed -e 's/^.*MD5\(\(:[0-9a-f]\{2\}\)\)/\1/'
#+end_src

#+RESULTS:

*** Help on KEYINFO commands

#+begin_src shell :results verbatim :exports both
gpg-connect-agent "help KEYINFO" /bye
#+end_src

#+RESULTS:
#+begin_example
# KEYINFO [--[ssh-]list] [--data] [--ssh-fpr[=algo]] [--with-ssh] <keygrip>
#
# Return information about the key specified by the KEYGRIP.  If the
# key is not available GPG_ERR_NOT_FOUND is returned.  If the option
# --list is given the keygrip is ignored and information about all
# available keys are returned.  If --ssh-list is given information
# about all keys listed in the sshcontrol are returned.  With --with-ssh
# information from sshcontrol is always added to the info. Unless --data
# is given, the information is returned as a status line using the format:
#
#   KEYINFO <keygrip> <type> <serialno> <idstr> <cached> <protection> <fpr>
#
# KEYGRIP is the keygrip.
#
# TYPE is describes the type of the key:
#     'D' - Regular key stored on disk,
#     'T' - Key is stored on a smartcard (token),
#     'X' - Unknown type,
#     '-' - Key is missing.
#
# SERIALNO is an ASCII string with the serial number of the
#          smartcard.  If the serial number is not known a single
#          dash '-' is used instead.
#
# IDSTR is the IDSTR used to distinguish keys on a smartcard.  If it
#       is not known a dash is used instead.
#
# CACHED is 1 if the passphrase for the key was found in the key cache.
#        If not, a '-' is used instead.
#
# PROTECTION describes the key protection type:
#     'P' - The key is protected with a passphrase,
#     'C' - The key is not protected,
#     '-' - Unknown protection.
#
# FPR returns the formatted ssh-style fingerprint of the key.  It is only
#     printed if the option --ssh-fpr has been used.  If ALGO is not given
#     to that option the default ssh fingerprint algo is used.  Without the
#     option a '-' is printed.
#
# TTL is the TTL in seconds for that key or '-' if n/a.
#
# FLAGS is a word consisting of one-letter flags:
#       'D' - The key has been disabled,
#       'S' - The key is listed in sshcontrol (requires --with-ssh),
#       'c' - Use of the key needs to be confirmed,
#       '-' - No flags given.
#
# More information may be added in the future.
OK
#+end_example
