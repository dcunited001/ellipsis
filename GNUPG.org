#+title: GnuPG Configuration
#+description:
#+startup: content
#+property: header-args        :tangle-mode (identity #o400) :mkdirp yes
#+property: header-args:conf   :tangle-mode (identity #o400) :mkdirp yes
#+property: header-args:sh     :tangle-mode (identity #o500) :mkdirp yes
#+property: header-args:bash   :tangle-mode (identity #o500) :mkdirp yes
#+property: header-args:scheme :tangle-mode (identity #o500) :mkdirp yes :comments link
#+options: toc:nil

* GPG Environment

** Pinentry

** Portable GPG

Use =guix pack= to pack up the binaries.

+ --system aarch64-linux :: makes the manifest portable to arm64
+ --relocatable :: twice enables binaries requiring user
  namespaces to function with a fallback execution engine
  - you may want the -RR relocatable option
+ -S :: creates links from the profile within the tar to the
  dependences in the guix packages
  
#+begin_src shell :eval no
guixpkg=$(guix pack --relocatable --system=x86_64-linux --compression=gzip --save-provenance \
      -L $HOME/.dotfiles -m ./gnupg-agent.scm \
      -S .bin=bin)
mkdir -p pkg
cp $guixpkg pkg
#+end_src

Then unpack:

#+begin_src shell :eval no
tar -C pkg -xzvf $guixpkg
#+end_src

The profile will be in =./gnu/store/*profile=

#+begin_src shell :eval no
tar --list -zf pkg/$guixpkg | grep 'profile/bin'

# or, more exactly, after unpacking with
guixprofile=$(find pkg/gnu/store -name "*-profile" -type d)
#guixprofile=$(find pkg/gnu/store -wholename "*profile/etc/profile")
ln -s $guixprofile .guix-gnupg
#+end_src

Then source the $guixprofile/etc/profile from a script

+ Some dependencies may require symlinking =-S lib=lib= or =-S libexec/libexec=.

Test the profile's binaries in a clean shell with:

#+begin_src shell :eval no
guix shell --profile=.guix-gnupg -- bash
#+end_src

***** TODO export a guix profile to the disk

* Init Script

#+begin_src emacs-lisp :tangle ./init.el :tangle-mode (identity #o400)
;; for real, the default indentiation in org-babel scripts is annoying as hell
(setq org-directory "~/org"
      org-adapt-indentation nil
      org-src-preserve-indentation t)
#+end_src

#+begin_src shell :tangle ./init.sh :shebang "#!/bin/sh" :tangle-mode (identity #o500)
export GPG_TTY="$(tty)"
export SECRETS_HOME="$(pwd)"
export GNUPGHOME="$SECRETS_HOME/.gnupg"

export PATH=$SECRETS_HOME/.bin:$PATH

# load GnuPG profile
GUIX_GNUPG=$SECRETS_HOME/.guix-gnupg
GUIX_EXTRA=$HOME/.guix-extra-profiles

if [ -f $GUIX_GNUPG/etc/profile ]; then
  GUIX_PROFILE=$GUIX_GNUPG
  source $GUIX_GNUPG/etc/profile
else
  echo "$GUIX_GNUPG not found. Trying $GUIX_EXTRA"
  if [ -d $GUIX_EXTRA ]; then
    GUIX_PROFILE=$HOME/.guix-extra-profiles/gnupg/gnupg
    source $HOME/.guix-extra-profiles/gnupg/gnupg/etc/profile
  else
    echo "$GUIX_PROFILE not found. access gpg* some other way"
    return 123
  fi
fi

export GPG_PINENTRY=$GUIX_PROFILE/bin/pinentry-curses

# SSH
unset SSH_AGENT_PID
export SSH_CONFIG_HOME="$SECRETS_HOME/.ssh"
export SSH_AUTH_SOCK="$(gpgconf --list-dirs agent-ssh-socket)"

# GPG Agent
# see below for startup scripts

# SSH Agent
# should be disabled

# Shroud Database
export SHROUD_CONFIG_FILE=$SECRETS_HOME/.shroud
export SHROUD_DATABASE_FILE=$SECRETS_HOME/.config/shroud/db.gpg

#+end_src

** SSH Agent (via GPG)

*** Notes

+ Using SSH via GnuPG
  - =/bye= redirects SSH calls to its socket to the GnuPG embedded SSH agent

+ The list of approved keys is stored in =~/.gnupg/sshcontrol=

+ If you use a PGP key for SSH auth (requires =Authentication= capability)
  - check for the key (when s/card is loaded) by listing keys or
    checking fingerprints: =ssh-add -l/L=
  - if the GPG is not on a s/card, then add the keygrip to =~/.gpg/sshcontrol=

This would cause GnuPG daemon's =GPG_TTY= variable to be updated on
every SSH command invocation: but allows you to enter the pin from the
same terminal you are ssh-connecting through. 

#+begin_src conf
Match host * exec "gpg-connect-agent UPDATESTARTUPTTY /bye"
#+end_src

** GPG Agent

*** Notes

+ Prefer to start with =gpgconf=
+ Yubikey: The =GPG_TTY= variable is how =pinentry= knows where to retrieve input

***** How to update this environment variable from another TTY? (broadcast?)

*** Start

**** With =gpg-connect-agent=

#+begin_src shell :tangle .bin/start-gpg-connect :shebang "#!/bin/sh" :tangle-mode (identity #o500)
export GPG_TTY="$(tty)"
unset SSH_AGENT_PID
export SSH_AUTH_SOCK="/run/user/$UID/gnupg/S.gpg-agent.ssh"
gpg-connect-agent update-startuptty /bye > /dev/null
#+end_src

**** With =gpgconf=

#+begin_src shell :tangle .bin/start-gpg :shebang "#!/bin/sh" :tangle-mode (identity #o500)
export GPG_TTY="$(tty)"
unset SSH_AGENT_PID
export SSH_AUTH_SOCK="$(gpgconf --list-dirs agent-ssh-socket)"
gpgconf --launch gpg-agent
#+end_src


* GPG

** GPG Config

*** Refs

- [[https://github.com/drduh/config/blob/master/gpg.conf][drduh/config]] gpg.conf
- [[https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html][GPG Config Options]] (docs)
- [[https://www.gnupg.org/documentation/manuals/gnupg/GPG-Esoteric-Options.html][GPG Esoteric Options]] (docs)

*** Defaults

#+begin_src conf :tangle ./.gnupg/gpg.conf.defaults
# Use AES256, 192, or 128 as cipher
personal-cipher-preferences AES256 AES192 AES

# Use SHA512, 384, or 256 as digest
personal-digest-preferences SHA512 SHA384 SHA256

# Use ZLIB, BZIP2, ZIP, or no compression
personal-compress-preferences ZLIB BZIP2 ZIP Uncompressed

# Default preferences for new keys
default-preference-list SHA512 SHA384 SHA256 AES256 AES192 AES ZLIB BZIP2 ZIP Uncompressed

# SHA512 as digest to sign keys
cert-digest-algo SHA512

# SHA512 as digest for symmetric ops
s2k-digest-algo SHA512

# AES256 as cipher for symmetric ops
s2k-cipher-algo AES256

# UTF-8 support for compatibility
charset utf-8

# Show Unix timestamps
fixed-list-mode

# No comments in signature
no-comments

# No version in output
no-emit-version

# Disable banner
no-greeting

# Long hexidecimal key format
keyid-format 0xlong

# Display UID validity
list-options show-uid-validity
verify-options show-uid-validity

# Display all keys and their fingerprints
with-fingerprint

# Display key origins and updates
#with-key-origin

# Cross-certify subkeys are present and valid
require-cross-certification

# Disable caching of passphrase for symmetrical ops
no-symkey-cache

# Enable smartcard
use-agent

# Disable recipient key ID in messages
throw-keyids

# Default/trusted key ID to use (helpful with throw-keyids)
#default-key 0xFF3E7D88647EBCDB
#trusted-key 0xFF3E7D88647EBCDB

# Group recipient keys (preferred ID last)
#group keygroup = 0xFF00000000000001 0xFF00000000000002 0xFF3E7D88647EBCDB

# Keyserver URL
#keyserver hkps://keys.openpgp.org
#keyserver hkps://keyserver.ubuntu.com:443
#keyserver hkps://hkps.pool.sks-keyservers.net
#keyserver hkps://pgp.ocf.berkeley.edu

# Proxy to use for keyservers
#keyserver-options http-proxy=http://127.0.0.1:8118
#keyserver-options http-proxy=socks5-hostname://127.0.0.1:9050

# Verbose output
#verbose

# Show expired subkeys
#list-options show-unusable-subkeys
#+end_src

** Agent Config

*** Defaults

#+begin_src conf :tangle ./.gnupg/gpg-agent.conf.defaults
# https://github.com/drduh/config/blob/master/gpg-agent.conf
# https://www.gnupg.org/documentation/manuals/gnupg/Agent-Options.html
enable-ssh-support
ttyname $GPG_TTY

# Yubikey PIN is cached by the yubikey itself
# - these options don't affect it. you must unplug the key.
default-cache-ttl 60
max-cache-ttl 120

# pinentry-program must be set or gpg-agent expects an X11 compatible one
pinentry-program $GPG_PINENTRY
#pinentry-program /usr/bin/pinentry-curses
#pinentry-program /usr/bin/pinentry-tty
#pinentry-program /usr/bin/pinentry-gtk-2
#pinentry-program /usr/bin/pinentry-x11
#pinentry-program /usr/bin/pinentry-qt
#pinentry-program /usr/local/bin/pinentry-curses
#pinentry-program /usr/local/bin/pinentry-mac
#pinentry-program /opt/homebrew/bin/pinentry-mac                 
#+end_src

* SSH

** Config

+ the env variable =${SSH_CONFIG_HOME}= can be used if exported

*** Refs

- [[https://github.com/drduh/config/blob/master/ssh_config][drduh/config]] (ssh_config)

*** Defaults

#+begin_src conf :tangle ./.ssh/config.defaults

# For now
IdentitiesOnly Yes

#Host router
#  IdentityFile ${SSH_CONFIG_HOME}/.ssh/router
#  HostName 192.168.1.1
#  Port 2222
#  User sysadm
#  ControlMaster auto
#  ControlPath ~/.ssh/master-%r@%h:%p
#  ControlPersist 300
Host gitlab.com
  User git
  ControlMaster no
  IdentitiesOnly yes
  IdentityFile ${SSH_CONFIG_HOME}/.ssh/gitlab
Host github.com
  User git
  ControlMaster no
  IdentitiesOnly yes
  IdentityFile ${SSH_CONFIG_HOME}/.ssh/github
  MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com,umac-128-etm@openssh.com,hmac-sha2-512,hmac-sha2-256,umac-128@openssh.com
Host *
  #ControlMaster auto
  #ControlPath ~/.ssh/master-%r@%h:%p
  #ControlPersist 300
  #AddKeysToAgent yes
  AddressFamily inet
  HashKnownHosts yes
  VisualHostKey yes
  PasswordAuthentication no
  ChallengeResponseAuthentication no
  StrictHostKeyChecking ask
  VerifyHostKeyDNS yes
  ForwardAgent no
  ForwardX11 no
  ForwardX11Trusted no
  ServerAliveInterval 300
  ServerAliveCountMax 2
  Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com
  MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com
  KexAlgorithms curve25519-sha256@libssh.org,diffie-hellman-group-exchange-sha256
  HostKeyAlgorithms ssh-ed25519-cert-v01@openssh.com,ssh-rsa-cert-v01@openssh.com,ssh-ed25519,ssh-rsa

#+end_src

** Daemon

#+begin_src conf :tangle .ssh/daemon.defaults
# https://github.com/drduh/config/blob/master/sshd_config
# https://linux.die.net/man/5/sshd_config
Port 22
AddressFamily inet
#ListenAddress 172.16.1.1
#ListenAddress 10.8.1.1
ListenAddress 0.0.0.0
HostKey /etc/ssh/ssh_host_key
HostKey /etc/ssh/ssh_host_rsa_key
AllowUsers sysadm
Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com
MACs hmac-sha2-512-etm@openssh.com
KexAlgorithms curve25519-sha256@libssh.org,diffie-hellman-group-exchange-sha256
HostKeyAlgorithms ssh-ed25519-cert-v01@openssh.com,ssh-rsa-cert-v01@openssh.com,ssh-ed25519,ssh-rsa
RekeyLimit 256M 1H
SyslogFacility AUTH
LogLevel VERBOSE
LoginGraceTime 10s
MaxStartups 1
MaxSessions 2
MaxAuthTries 3
ClientAliveInterval 30
ClientAliveCountMax 20
PermitRootLogin no
StrictModes yes
PubkeyAuthentication yes
AuthorizedKeysFile %h/.ssh/authorized_keys
IgnoreRhosts yes
PasswordAuthentication no
PermitEmptyPasswords no
HostbasedAuthentication no
ChallengeResponseAuthentication no
Compression delayed
AllowTcpForwarding no
X11Forwarding no
GatewayPorts no
PermitTunnel no
TCPKeepAlive yes
UseDNS no
PrintMotd no
PrintLastLog yes
PermitUserEnvironment no
#Subsystem sftp  /usr/lib/sftp-server
#Subsystem sftp  /usr/libexec/sftp-server
#TrustedUserCAKeys /etc/ssh/ca.pub
#Match User proxy
#       AllowTcpForwarding yes
#+end_src

* Shroud

This is a password/secrets management tool. In the =gnupg-agent.scm=
profile, =shroud-nox= references a package in [[https://github.com/dcunited001/ellipsis/blob/master/ellipsis/packages/password-utils.scm][dcunited001/ellipsis]],
which is not [yet?] a channel.

For this kind of secrets management, shroud is a good
choice:

+ Minimal dependencies: guile scheme, gpg
+ GPG integration: and this means smartcard integration.
+ In memory: GPG means the secrets are pulled into RAM and then gone.

Alternatives considered:

+ tomb :: This is a nice one, but requires zsh. I don't fully trust
  zsh and would prefer to avoid the dependency.
+ pwsafe :: I couldn't find a Guix package without X11/GTK
  dependencies. There are several packages, but it's a bit confusing.
+ file-system-based tools :: LUKS is secure ... until you mount
  it. Other tools like truecrypt/veracrypt/fscrypt are similar. I
  don't want to have to trust even my own user. If it is mounted as a
  file-system, then other processes can impersonate my user and access
  the data.
  - with GPG-based tools, if my yubikey is required, then it is much
    more difficult for processes to impersonate authorization.

** Config

See the environment variables in =init.sh=

*** Defaults

#+begin_src scheme :tangle .shroud.defaults
'((user-id . "myemail@fdsa.com"))
#+end_src

* Tangling

** File Ownership/Permissions

I couldn't find options to specify file owner/group when tangling
files. The permissions of these files are critical. GPG/Agent and SSH
will refuse to function if the permissions are not set correctly. When
the permissions are not in =400,600,700=, then the group should
probably be set to =wheel=.

* Entropy

I don't know what I'm doing, so you've been warned lol. It generates keys very
fast though, so I guess it works?

** Add an entropy source

Use [[Entropy s][Yubikey as entropy source]]. GPG agent should already be running.

Create a new cert in slot 9a (this will replace the existing 9a PIV cert!)

#+begin_src shell :eval no
ykman piv keys generate --algorithm ECCP256 9a pubkey.pem
#+end_src

Run =rngd= in background using Yubikey as =/dev/random= source:

#+begin_src shell :eval no
rngd -x hwrng -x tpm -x rdrand -x jitter -n pkcs11 -b -W 4096 -f
#+end_src

Options:

+ -x :: disables an existing rng source. =rngd -l= to list
+ -n pkcs11 :: specifiy the pkcs11 source
+ -b :: run =rngd= in the background
+ -W 4096 :: specify the intended entropy size
+ -f :: keep running even when full

** Test with =rngtest=

Compare lines with =FIPS 140-2 successes/failures=. It should be very close to 100%.

#+begin_src shell :eval no
cat /dev/random | rngtest -c 1000
#+end_src

* Backups

You should never have an active/connected network device when working with these
file systems. The system should have been booted offline and have remained
offline the entire time. It should never connect to the network before being
reset. Ideally, it should be a system that has no disks other than what is
necessary.

The goal is to get the keys onto the yubikey where they are safe. They can also be generated on the yubikey itself.

** Digital

Flash storaget is thought to become less reliable with time if its CMOS is not powered (i.e. if you don't plug it in for long periods of time)

*** Test the flash storage with F3

F3 isn't really a comprehensive test, but this will help you preempt problems with counterfeit flash storage. It will mainly tell you if there are bad sectors where =f3brew= wrote data, but could not read it.

=f3brew= will destructively write to the entire disk!

#+begin_src shell :eval no
f3brew /dev/sdX
#+end_src

This will take a long time. It will prompt you to disconnect/reconnect the storage device. At the end, it will tell you, in hex, how much data was written.

*** Provision the flash partitions for RAID -1

Calculate the partition sizes. Check the number of sectors =n=.

#+begin_src shell :eval no
LC_ALL=C fdisk -l /dev/sdX
#+end_src

Take =m = (n/4) % 2048=, since =cfdisk= will round partition sizes down to the nearest multiple of =2048=

Use =cfdisk= to test the partition sizes. You should end up with four. Ensure that the partition sizes, to the sector, are identical.

#+begin_src shell :eval no
cfdisk -z /dev/sdX
#+end_src

Just create the partitions. Use =mkfs.ext2= to format them later.

*** Create a partition and backup the files

Format the first partition with =mkfs.ext2=.

#+begin_src shell :eval no
mkfs.ext2 /dev/sdX1 -L gpg-$(date +%F)
#+end_src

For further data redundancy, you can use btrfs which can totally duplicate its data and metadata. This will reduce the total disk size by +50%.

#+begin_src shell :eval no
mkfs.btrfs -L gpg-$(date +%F) -d dup -m dup
#+end_src

When mounting, you should ensure =readonly= and =noatime= are consistently
applied to prevent unintentional mutation of the data, which will keep the disk copies in sync unless they are intentionally modified.

#+begin_src shell :eval no
cryptsetup luksOpen /dev/sdXn backupn
mount -r -o noatime /dev/mapper/backupn /mnt/backupn -o noatime
#+end_src

*** Duplicate the partitions

View the partitions with =lsblk= and copy the images from =/dev/sdX1= to =/dev/sdX2= and =/dev/sdY1= and so forth.

#+begin_src shell :eval no
# i'm not sure whether bs=1M will affect the block structure of the disk
dd if=/dev/sdX1 of=/dev/sdX2 status=progress
#+end_src

This will not affect the partition labels which exist inside the LUKS volumes.
If you want to mount them with the labels, then change with with =e2label
/dev/sdXn newLabel= while the LUKS volume is open.

*** Close the luks device

Since the partition is not inside an LVM2 volume, you can simply use =dmsetup info= to query the block device mappings to find the name and:

#+begin_src shell :eval no
umount /mnt/backupn
cryptsetup luksClose backupn
#+end_src

Working with multiple identical partitions is a bit tricky, esp. when they do
contain LVM2 volumes. At any point, you should not attempt to mount devices with
the same LUKS block device ID's or PV/LV ID's. Ensure that they are completely
unmounted with =dmsetup info= et alias.

** Paperkey

Paperkey is included on the image and will export the password-protected GPG
keys to a txt file, which you can print. If unlike me you have more than a 5
digit salary and you print them out, they can be placed in a safety deposit box.

This gives you an option to generate new keys and issue/use revocation certs, in
case the backup is lost.

*** Backup

Export an unarmored copy of the master secret to a secure disk.

#+begin_src shell :eval no
gpg --export-secret-keys $KEYID > $GNUPGHOME/mastersub.unarmored.key
paperkey --secret-key .gnupg/mastersub.unarmored.key --output mastersub.paperkey.txt
#+end_src

Print it and then clear your printer's internal cache...
