#+title: GnuPG Configuration
#+description:
#+startup: content
#+property: header-args            :tangle-mode (identity #o400) :mkdirp yes
#+property: header-args:conf       :tangle-mode (identity #o400) :mkdirp yes
#+property: header-args:sh         :tangle-mode (identity #o500) :mkdirp yes
#+property: header-args:bash       :tangle-mode (identity #o500) :mkdirp yes
#+property: header-args:scheme     :tangle-mode (identity #o700) :mkdirp yes
#+property: header-args:emacs-lisp :tangle-mode (identity #o600) :mkdirp yes
#+options: toc:nil

* Resources

** GPG

*** Configuration

+ [[https://github.com/drduh/config/blob/master/gpg.conf][drduh/config]] gpg.conf
+ [[https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html][GPG Config Options]] (docs)
+ [[https://www.gnupg.org/documentation/manuals/gnupg/GPG-Esoteric-Options.html][GPG Esoteric Options]] (docs)

*** Source [[https://git.gnupg.org/cgi-bin/gitweb.cgi][git.gnupg.org]]

[[https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob;f=agent/keyformat.txt;hb=HEAD][keyformat.txt]] the format of S-expressions in private keys. It answers all your
questions about life, about the eternal mysteries and about what should be
frequently mentioned by developers online ... but is not.

You all may think you have imposter syndrome ... but you don't. You really
don't. It takes me forever to learn anything bc of isolation, but you can tell a
lot about how people use software by how difficult it is to find answers to
questions that people should be asking.

** GPG Agent

See [[https://www.gnupg.org/documentation/manuals/gnupg/Agent-Protocol.html][Agent ASSUAN protocol]] for other things like:

#+begin_example shell
gpg-connect-agent updatestartuptty /bye > /dev/null
#+end_example

Commands need to be enclosed in quotes:

#+begin_example shell
gpg-connect-agent "help getinfo"
#+end_example

Getting a REPL with =gpg-connect-agent= allows =help [cmd]=

And, =/if= you want GPG problems at scale, =/then= you can write scripts. I'm
just curious about questions that are hard to see, like SSH =ControlMaster=.

Getting leads on the above was actually pretty difficult ([[https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob;f=agent/command.c;h=9481f47c3ec0b19af47a4db96b866e1928292caf;hb=HEAD#l3760][./agent/commands.c]]) I
guess since no one customizes anything and the GUI does most of it for them.

** Crypto
+ [[https://developers.redhat.com/blog/2017/10/05/entropy-rhel-based-cloud-instances#][Entropy in RHEL-based cloud instances]]
+ [[https://www.random.org/randomness/][Introduction to Randomness and Random Numbers]]

** GPG Integration
+ [[https://alexschroeder.ch/cgit/ugg/about/][The Using GPG Guide]]
+ [[https://git.vdm.dev/knowledge/YubiKey-Guide][VDM Yubikey-Guide]]
+ [[https://github.com/drduh/YubiKey-Guide][drduh/YubiKey-Guide]]

*** Emacs
+ [[https://www.gnu.org/software/emacs/manual/html_mono/auth.html][auth-source]]

Emacs Wiki ([[https://www.emacswiki.org/emacs/Using_GPG][GPG topic]])

+ [[https://www.emacswiki.org/emacs/Gmail%2c_Gnus_and_GPG][Gmail, Gnus and GPG]]
+ [[https://www.emacswiki.org/emacs/GnuPG][Gnu PG]]
+ [[https://www.emacswiki.org/emacs/AutoEncryption][Auto Encryption]]

Mastering Emacs

+ [[https://www.masteringemacs.org/article/keeping-secrets-in-emacs-gnupg-auth-sources][Keeping Secrets in Emacs with GnuPG and Auth Sources]]

*** Forwarding
+ [[https://rabbithole.wwwdotorg.org/2021/03/03/gpg-agent-fwding-over-ssh.html][GPG Agent Forwarding via SSH]]

*** Thunderbird
+ [[https://support.mozilla.org/en-US/kb/openpgp-thunderbird-howto-and-faq][OpenPGP in Thunderbird: How To and FAQ]]
+ [[https://wiki.mozilla.org/Thunderbird:OpenPGP:Smartcards][Thunderbird, OpenPGP and Smartcards]]

*** KDE

+ [[https://ebzzry.com/en/gsk/][Setting up GPG and SSH in KDE]]

* GPG Environment

The table approach in [[file:ANSIBLE.org][ANSIBLE.org]] is a bit confusing. This is more verbose, yet
more direct. It involves less metaprogramming.

#+begin_src emacs-lisp :eval no :tangle no
(setenv "SECRETS_HOME" ".gnupg.test")
#+end_src

#+name: secretshome
#+begin_src emacs-lisp
(or (getenv "SECRETS_HOME") ".")
#+end_src

** GPG TTY

For the programs that need to have GPG access, I will configure things like
=GPG_TTY= in the startup script or in the flatpak overrides. I really just don't
trust X11, not that Wayland is much better since it invites an XWayland
dependency for everything.

** Pinentry

#+name: gpgpinentry
#+begin_src emacs-lisp :tangle no
"pinentry-curses"
#+end_src

#+RESULTS: gpgpinentry
: pinentry-curses

** Personal Keys

Change these to the fingerprints of your personal keys

#+name: gpgmaster
#+begin_src shell
"0x9FCE9B3064CED760"
#+end_src

#+RESULTS: gpgmaster
: 9FCE9B3064CED760

#+name: gpgsign
#+begin_src shell
"0xB5E0535B23DD6A7A"
#+end_src

#+RESULTS: gpgsign
: B5E0535B23DD6A7A

#+name: gpgcrypt
#+begin_src shell
"0x5AA3269777368E0F"
#+end_src

#+RESULTS: gpgcrypt
: 5AA3269777368E0F

#+name: gpgauth
#+begin_src shell
"0xFC275EE2A3547885"
#+end_src

#+RESULTS: gpgauth
: FC275EE2A3547885

#+begin_src shell :noweb-ref gpgring :noweb yes :noweb-sep ""
export PINENTRY=<<gpgpinentry>>
export GPGMASTER=<<gpgmaster>>
export GPGSIGN=<<gpgsign>>
export GPGCRYPT=<<gpgcrypt>>
export GPGAUTH=<<gpgauth>>
#+end_src

#+RESULTS:

** Guix Profile

The Guix profile will need to be installed. Unless =GNUPG_PATH= is set when
=init-gpg.sh= is sourced, then the profile is expected to be installed to
=$GUIX_EXTRA/gpgagent/gpgagent=

It makes more sense to do this in a manifest than to add a custom package to a
guix channel. Thankfully the guix transformations are very flexible. See =guix
shell --help-transform= for more information.

#+begin_src scheme :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.config/guix/manifests/gpgagent.scm")
(use-modules (guix packages)
             (guix transformations)
             (guix download)
             (guix git-download)
             (gnu packages base)
             (gnu packages guile)
             (gnu packages gnupg)

             (gnu packages autotools)
             (gnu packages pkg-config)

             (gnu packages password-utils))

;; The project only builds in xclip behavior
;; if it finds the dependencies. it's
;; much smaller without them.
(define-public shroud-nox
  (package
    (inherit shroud)
    (name "shroud-nox")
    (version "0f5a58da63cacce3bb839427fd1d87c9230800ad")
    (source (origin
              (method git-fetch)
              (uri (git-reference
                    (url "https://git.dthompson.us/shroud.git")
                    (commit version)))
              (sha256
               (base32
                "0xn916i8ma9xinavq9avfi4rg9770c0hzimbwglqq1slfwa8c3nq"))
              (file-name (git-file-name name version))))
    (inputs
     (list guile-2.2 gnupg))

    (native-inputs
     (list pkg-config autoconf automake))))

;; needs to build from master to set alternate config/db
(define shroud-master
  (options->transformation
   '((with-branch . "shroud=master"))))

(packages->manifest
 (list gnupg
       pinentry-tty
       shroud-nox))
#+end_src

**** TODO include SSH/opensc in the profile?
or use separate guix profiles? (on either USB or the system)

** Portable GPG

Honestly, using =guix pack= to create a portable guix profile wasn't beneficial
enough to offset the complexity.  A portible profile is arguably more useful for
Ansible -- especially for hackers operating behind enemy lines, lol -- so I
moved any notes to [[file:ANSIBLE.org::*Guix Profile][ANSIBLE.org.]]

#+begin_quote
Firewalling SSH? oh noes: on what port?

lol i hope you have deep-packet inspection.
#+end_quote

* Init Script

#+begin_src shell :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.gnupg/init-gpg.sh") :shebang "#!/bin/sh" :tangle-mode (identity #o500) :noweb yes
<<gpgring>>
#+end_src

If =SECRETS_HOME= is not set, it's set to =$(pwd)=. Do this before sourcing
=init-gpg.sh=. Another option is to link =$HOME/.gnupg= to
=$SECRETS_HOME/.gnupg= and then you can source the script in a fresh shell.

#+begin_src shell :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.gnupg/init-gpg.sh") :tangle-mode (identity #o500)
if [ -z $SECRETS_HOME ];then
    export SECRETS_HOME="$(pwd)"
    echo "SECRETS_HOME=$SECRETS_HOME"
fi

# if not using on a system where $GNUPGHOME == $SECRETS_HOME/.gnupg
# then make it so before sourcing the script
if [ -z $GNUPGHOME ];then
    export GNUPGHOME=$HOME/.gnupg
    echo "GNUPGHOME=$GNUPGHOME"
fi
export PATH=$SECRETS_HOME/.bin:$PATH

# unless there is a specific $GNUPG_PATH, use a guix profile
if [ -z $GNUPG_PATH ];then
    # then load GnuPG profile
    GUIX_EXTRA=$HOME/.guix-extra-profiles
    GUIX_PROFILE=$GUIX_GNUPG_PROFILE
    if [ -z $GUIX_PROFILE ];then
        GUIX_PROFILE=$GUIX_EXTRA/gpgagent/gpgagent
    fi
    source $GUIX_PROFILE/etc/profile
    GNUPG_PATH=$GUIX_PROFILE/bin
fi

# GPG Agent
# see below for startup scripts

# SSH Agent
# should be disabled

# Shroud Database
export SHROUD_CONFIG_FILE=$SECRETS_HOME/.shroud
export SHROUD_DATABASE_FILE=$SECRETS_HOME/.config/shroud/db.gpg
#+end_src

** SSH Agent (via GPG)

*** Notes

+ Using SSH via GnuPG
  - =/bye= redirects SSH calls to its socket to the GnuPG embedded SSH agent

+ The list of approved keys is stored in =~/.gnupg/sshcontrol=

+ If you use a PGP key for SSH auth (requires =Authentication= capability)
  - check for the key (when s/card is loaded) by listing keys or
    checking fingerprints: =ssh-add -l/L=
  - if the GPG is not on a s/card, then add the keygrip to =~/.gpg/sshcontrol=

This would cause GnuPG daemon's =GPG_TTY= variable to be updated on
every SSH command invocation: but allows you to enter the pin from the
same terminal you are ssh-connecting through. 

#+begin_src conf
Match host * exec "gpg-connect-agent UPDATESTARTUPTTY /bye"
#+end_src

** GPG Agent

*** Start


To start GPG Agent, source the above =init-gpg.sh= script, then run =start-gpg=
or =start-gpg-connect=. My notes say to prefer starting =gpg-agent= via
=gpg-conf= but I honestly can't remember why.

**** With =gpg-connect-agent=

#+begin_src shell :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.bin/start-gpg-connect") :shebang "#!/bin/sh" :tangle-mode (identity #o500)
export GPG_TTY="$(tty)"
unset SSH_AGENT_PID
export SSH_AUTH_SOCK="/run/user/$UID/gnupg/S.gpg-agent.ssh"
gpg-connect-agent update-startuptty /bye > /dev/null
#+end_src

**** With =gpgconf=

Prefer to start with =gpgconf=

#+begin_src shell :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.bin/start-gpg") :shebang "#!/bin/sh" :tangle-mode (identity #o500)
export GPG_TTY="$(tty)"
unset SSH_AGENT_PID
export SSH_AUTH_SOCK="$(gpgconf --list-dirs agent-ssh-socket)"
gpgconf --launch gpg-agent
#+end_src

**** Without =ssh=

***** TODO init script without ssh

*** Application Integration

For any given appliation, either its launch scripts or the window manager's
shell should have =GPG_TTY= set. Obviously, the whole point of doing things this
way is so applciations in X11 have minimal awareness of GPG -- this is me being
paranoid, but honestly, it's crazy to think that it's done that way. Of course,
smartcards improve the potential for X11 keylogging.

For flatpak apps:

+ Link =$HOME/.gnupg= to =$SECRETS_HOME/.gnupg=
+ Run =flatpak --env=GPG_TTY=/dev/ttyX org.mozilla.Thunderbird=. This can also
  be included in a script, called after =GPG_TTY= has been established for the
  =gpg-agent=.

#+begin_src shell :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.bin/flatpak-gpg-overrides") :shebang "#!/bin/sh" :tangle-mode (identity #o500)
flatpak --user override --env=GPG_TTY=$(tty) org.mozilla.Thunderbird
#+end_src

This apparently works alright, though I needed to paste in the public key to
circumvent the flatpak restrictions on file access.

[[./img/thunderbird-signed.jpg]]

** Shell Examples

Cut the keys out of the =gpg -k= output.

#+begin_example shell
gpg -k | grep -e "^sub" | cut -b 16-33
#+end_example

Get the environment variables that =gpg= passes to =gpg-agent=. These are the
only variables permitted in =gpg-agent.conf=.

#+begin_src shell :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.bin/gpg-agent-env") :shebang "#!/bin/sh" :tangle-mode (identity #o500)
gpg-connect-agent 'getinfo std_env_names' /bye | awk '$1=="D" {print $2}'
#+end_src

Troubleshoot =gpg-agent=

#+begin_src shell :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.bin/start-gpg-debug") :shebang "#!/bin/sh" :tangle-mode (identity #o500)
export GPG_TTY="$(tty)"
unset SSH_AGENT_PID
export SSH_AUTH_SOCK="$(gpgconf --list-dirs agent-ssh-socket)"
gpg-agent --daemon --no-detach -v -v --debug-level advanced
#+end_src

Troubleshoot =gpg-agent= with:

+ =--debug-pinentry=
+ =--debug 1024= which is required

#+begin_src shell :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.bin/start-gpg-debug-pinentry") :shebang "#!/bin/sh" :tangle-mode (identity #o500)
export GPG_TTY="$(tty)"
unset SSH_AGENT_PID
export SSH_AUTH_SOCK="$(gpgconf --list-dirs agent-ssh-socket)"
gpg-agent --daemon --no-detach -v -v --debug-pinentry --debug 1024
#+end_src

* GPG

** GPG Config

*** Defaults

#+begin_src conf :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.gnupg/gpg.conf.defaults")
# Use AES256, 192, or 128 as cipher
personal-cipher-preferences AES256 AES192 AES

# Use SHA512, 384, or 256 as digest
personal-digest-preferences SHA512 SHA384 SHA256

# Use ZLIB, BZIP2, ZIP, or no compression
personal-compress-preferences ZLIB BZIP2 ZIP Uncompressed

# Default preferences for new keys
default-preference-list SHA512 SHA384 SHA256 AES256 AES192 AES ZLIB BZIP2 ZIP Uncompressed

# SHA512 as digest to sign keys
cert-digest-algo SHA512

# SHA512 as digest for symmetric ops
s2k-digest-algo SHA512

# AES256 as cipher for symmetric ops
s2k-cipher-algo AES256

# UTF-8 support for compatibility
charset utf-8

# Show Unix timestamps
fixed-list-mode

# No comments in signature
no-comments

# No version in output
no-emit-version

# Disable banner
no-greeting

# Long hexidecimal key format
keyid-format 0xlong

# Display UID validity
list-options show-uid-validity
verify-options show-uid-validity

# Display all keys and their fingerprints
with-fingerprint

# Display key origins and updates
#with-key-origin

# Cross-certify subkeys are present and valid
require-cross-certification

# Disable caching of passphrase for symmetrical ops
no-symkey-cache

# Enable smartcard
use-agent

# Disable recipient key ID in messages
throw-keyids

# Default/trusted key ID to use (helpful with throw-keyids)
#default-key 0xFF3E7D88647EBCDB
#trusted-key 0xFF3E7D88647EBCDB

# Group recipient keys (preferred ID last)
#group keygroup = 0xFF00000000000001 0xFF00000000000002 0xFF3E7D88647EBCDB

# Keyserver URL
#keyserver hkps://keys.openpgp.org
#keyserver hkps://keyserver.ubuntu.com:443
#keyserver hkps://hkps.pool.sks-keyservers.net
#keyserver hkps://pgp.ocf.berkeley.edu

# Proxy to use for keyservers
#keyserver-options http-proxy=http://127.0.0.1:8118
#keyserver-options http-proxy=socks5-hostname://127.0.0.1:9050

# Verbose output
#verbose

# Show expired subkeys
#list-options show-unusable-subkeys
#+end_src

** Agent Config

*** Defaults

#+begin_src conf :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.gnupg/gpg-agent.conf.defaults")
# https://github.com/drduh/config/blob/master/gpg-agent.conf
# https://www.gnupg.org/documentation/manuals/gnupg/Agent-Options.html
enable-ssh-support
ttyname $GPG_TTY

# Yubikey PIN is cached by the yubikey itself
# - these options don't affect it. you must unplug the key.
default-cache-ttl 60
max-cache-ttl 120

# pinentry-program must be set or gpg-agent expects an X11 compatible one
pinentry-program /usr/bin/pinentry-tty
#pinentry-program /usr/bin/pinentry-curses
#pinentry-program /usr/bin/pinentry-tty
#pinentry-program /usr/bin/pinentry-gtk-2
#pinentry-program /usr/bin/pinentry-x11
#pinentry-program /usr/bin/pinentry-qt
#pinentry-program /usr/local/bin/pinentry-curses
#pinentry-program /usr/local/bin/pinentry-mac
#pinentry-program /opt/homebrew/bin/pinentry-mac
#+end_src

** SCDaemon Config

The daemon is failing when =pcscd= and =scdaemon= already have a connection to
the Yubikey for the PIV/SSH application. (TODO: verify that this is the problem)

The =shared-access= option is dangerous according to the =scdaemon= manpages,
since the process caches information from the card.

#+begin_src conf :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.gnupg/scdaemon.conf.defaults")
reader-port Yubico Yubi
# shared-access
#+end_src

** SSH Control

Running =ssh-add= while GPG is running as an =ssh-agent= will:

- Prompt for the ssh key passphrase, decrypt it, and test for vaildity.
- Ask for a new passphrase. You could simply use the same passphrase ... but you
  do need one.
- The SSH key's keygrip is added into the =$GNUPGHOME/sshcontrol= file.
- It then stores the SSH key into the GPG private key format into
  =$GNUPGHOME=.

Without a passphrase, it's essentially unprotected as a string of octal
characters. It was pretty difficult to find a definitive answer on this.  People
will tell you to enter one, but I was kinda hoping it would be encrypted by the
GPG auth or encryption subkey.

The  [[https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob;f=agent/keyformat.txt;hb=HEAD][keyformat]] is described here.

Also, the =sshcontrol= file can be edited to add a priority to SSH keys, so when
SSH's post-modern interpretation of your =ssh_config= ignores things like
=IdentitiesOnly=, you may not be able to prevent it from doing that, but you can
make it try your keys in a specific order ...

*** TL;DR;

I could have really, reallllly used some feedback on my SSH/GPG workflow
& configs ... and actually, simply hearing that "your gpg authenticaion key will
sign the public key and send the result to prove identity, dumbass" would have
been enough. That was my first impression (2+ years ago), but I didn't realize
=SSH_AUTH_SOCK= wasn't defined in an environment (or my key didn't end with
=*.pub= something), so I just assumed that I had assumed wrong and GPG wouldn't
use any keys that hadn't been added with =ssh-add=. It would have really helped
to hear "yeh, that _is_ possible, it doesn't work for you?"

It really cost me an unbelievable amount of time. Trying to go about a homelab
while you constantly need to rework SSH and you can't consistently use
=ssh_copy_id= is a major pain in the ass. Hopefully, you're not too worried
about your own ego or narratives about "career assassination" because you'd
probably look incompetent.

No, I'm not actually stupid. I'm alienated. You may think you have superpowers,
living in SF or some tech hub, but what you have is /social access/. You benefit
from network effects to which you are blissfully ignorant. When your dumbass
social justice bullshit programs people through gaslighting, poison pen and
defamation:

/it _ruins_ peoples lives, it _sows enmity_, it _creates rifts_ and it _curses
society_ with decades of _problems at scale_/ ... you're ironically the root of
all problems, many of which you'll eventually complain about and protest
over. Go read a sutra or learn to love your enemies. You suck at everything you
want to do.

Oh, and there /IS/ a way to get GPG's =ssh-agent= emulation to interact with the
Yubikey =PIV= application ... so maybe learning all about that wasn't a complete
waste of time?

*** Testing SSH Keys

#+begin_src

#+end_src

* Shroud

This is a password/secrets management tool. In the =gnupg-agent.scm=
profile, =shroud-nox= references a package in [[https://github.com/dcunited001/ellipsis/blob/master/ellipsis/packages/password-utils.scm][dcunited001/ellipsis]],
which is not [yet?] a channel.

For this kind of secrets management, shroud is a good
choice:

+ Minimal dependencies: guile scheme, gpg
+ GPG integration: and this means smartcard integration.
+ In memory: GPG means the secrets are pulled into RAM and then gone.

Alternatives considered:

+ tomb :: This is a nice one, but requires zsh. I don't fully trust
  zsh and would prefer to avoid the dependency.
+ pwsafe :: I couldn't find a Guix package without X11/GTK
  dependencies. There are several packages, but it's a bit confusing.
+ file-system-based tools :: LUKS is secure ... until you mount
  it. Other tools like truecrypt/veracrypt/fscrypt are similar. I
  don't want to have to trust even my own user. If it is mounted as a
  file-system, then other processes can impersonate my user and access
  the data.
  - with GPG-based tools, if my yubikey is required, then it is much
    more difficult for processes to impersonate authorization.

** Config

See the environment variables in =init.sh=

*** Defaults

#+begin_src scheme :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.shroud.defaults")
'((user-id . "myemail@fdsa.com"))
#+end_src

* Emacs

** Loading the profile

Either Link =~/.emacs.d= to =$SECRETS_HOME= or, using chemacs, run:

#+begin_src shell :eval no
emacs --with-profile '((user-emacs-directory . (getenv "SECRETS_HOME")))'
#+end_src

** Guix packages:

**** TODO setup a portable emacs profile

Which will be of limited utility if: any bin tools or path deps don't work/interact properly on the system

** Babel

The essentials

#+begin_src emacs-lisp :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.emacs.d/init.el")
(setq org-directory "~/org"
      org-adapt-indentation nil
      org-src-preserve-indentation t)

(defun read-only-when-pgp ()
  (when (and (fboundp #'buffer-file-name)
             (buffer-file-name)
             (string-match "\\.key$" (buffer-file-name)))
    (read-only-mode)))

(add-to-list 'after-change-major-mode-hook #'read-only-when-pgp t)
#+end_src

And if you want lispy to be configured:

#+begin_example emacs-lisp
(when (bound-and-true-p lispy-mode)
  (cl-dolist (hook '(scheme-mode-hook
                     emacs-lisp-mode-hook
                     lisp-data-mode-hook
                     ielm-add))
    (add-hook hook #'lispy-mode)))

(advice-add 'lispy-goto-symbol-elisp :override #'xref-find-definitions '(name "dc/nanon"))
#+end_example

** Tangling

*** File Ownership/Permissions

I couldn't find options to specify file owner/group when tangling
files. The permissions of these files are critical. GPG/Agent and SSH
will refuse to function if the permissions are not set correctly. When
the permissions are not in =400,600,700=, then the group should
probably be set to =wheel=.

* Entropy

I don't know what I'm doing, so you've been warned lol. It generates keys very
fast though, so I guess it works?

** Add an entropy source

Use [[Entropy s][Yubikey as entropy source]]. GPG agent should already be running.

Create a new cert in slot 9a (this will replace the existing 9a PIV cert!)

#+begin_src shell :eval no
ykman piv keys generate --algorithm ECCP256 9a pubkey.pem
#+end_src

Run =rngd= in background using Yubikey as =/dev/random= source:

#+begin_src shell :eval no
rngd -x hwrng -x tpm -x rdrand -x jitter -n pkcs11 -b -W 4096 -f
#+end_src

Options:

+ -x :: disables an existing rng source. =rngd -l= to list
+ -n pkcs11 :: specifiy the pkcs11 source
+ -b :: run =rngd= in the background
+ -W 4096 :: specify the intended entropy size
+ -f :: keep running even when full

**** TODO verify whether =-o /tmp/yubirng= as output is required

** Test with =rngtest=

Compare lines with =FIPS 140-2 successes/failures=. It should be very close to 100%.

#+begin_src shell :eval no
cat /dev/random | rngtest -c 1000
#+end_src

* Backups

You should never have an active/connected network device when working with these
file systems. The system should have been booted offline and have remained
offline the entire time. It should never connect to the network before being
reset. Ideally, it should be a system that has no disks other than what is
necessary.

The goal is to get the keys onto the yubikey where they are safe. They can also be generated on the yubikey itself.

** Digital

Flash storaget is thought to become less reliable with time if its CMOS is not powered (i.e. if you don't plug it in for long periods of time)

*** Test the flash storage with F3

F3 isn't really a comprehensive test, but this will help you preempt problems with counterfeit flash storage. It will mainly tell you if there are bad sectors where =f3brew= wrote data, but could not read it.

=f3brew= will destructively write to the entire disk!

#+begin_src shell :eval no
f3brew /dev/sdX
#+end_src

This will take a long time. It will prompt you to disconnect/reconnect the storage device. At the end, it will tell you, in hex, how much data was written.

*** Provision the flash partitions for RAID -1

Calculate the partition sizes. Check the number of sectors =n=.

#+begin_src shell :eval no
LC_ALL=C fdisk -l /dev/sdX
#+end_src

Take =m = (n/4) % 2048=, since =cfdisk= will round partition sizes down to the nearest multiple of =2048=

Use =cfdisk= to test the partition sizes. You should end up with four. Ensure that the partition sizes, to the sector, are identical.

#+begin_src shell :eval no
cfdisk -z /dev/sdX
#+end_src

Just create the partitions. Use =mkfs.ext2= to format them later.

*** Create a partition and backup the files

Format the first partition with =mkfs.ext2=.

#+begin_src shell :eval no
mkfs.ext2 /dev/sdX1 -L gpg-$(date +%F)
#+end_src

For further data redundancy, you can use btrfs which can totally duplicate its data and metadata. This will reduce the total disk size by +50%.

#+begin_src shell :eval no
mkfs.btrfs -L gpg-$(date +%F) -d dup -m dup
#+end_src

When mounting, you should ensure =readonly= and =noatime= are consistently
applied to prevent unintentional mutation of the data, which will keep the disk copies in sync unless they are intentionally modified.

#+begin_src shell :eval no
cryptsetup luksOpen /dev/sdXn backupn
mount -r -o noatime /dev/mapper/backupn /mnt/backupn -o noatime
#+end_src

*** Duplicate the partitions

View the partitions with =lsblk= and copy the images from =/dev/sdX1= to =/dev/sdX2= and =/dev/sdY1= and so forth.

#+begin_src shell :eval no
# i'm not sure whether bs=1M will affect the block structure of the disk
dd if=/dev/sdX1 of=/dev/sdX2 status=progress
#+end_src

This will not affect the partition labels which exist inside the LUKS volumes.
If you want to mount them with the labels, then change with with =e2label
/dev/sdXn newLabel= while the LUKS volume is open.

*** Close the luks device

Since the partition is not inside an LVM2 volume, you can simply use =dmsetup info= to query the block device mappings to find the name and:

#+begin_src shell :eval no
umount /mnt/backupn
cryptsetup luksClose backupn
#+end_src

Working with multiple identical partitions is a bit tricky, esp. when they do
contain LVM2 volumes. At any point, you should not attempt to mount devices with
the same LUKS block device ID's or PV/LV ID's. Ensure that they are completely
unmounted with =dmsetup info= et alias.

** Paperkey

Paperkey is included on the image and will export the password-protected GPG
keys to a txt file, which you can print. If unlike me you have more than a 5
digit salary and you print them out, they can be placed in a safety deposit box.

This gives you an option to generate new keys and issue/use revocation certs, in
case the backup is lost.

*** Backup

Export an unarmored copy of the master secret to a secure disk.

#+begin_src shell :eval no
gpg --export-secret-keys $KEYID > $GNUPGHOME/mastersub.unarmored.key
paperkey --secret-key .gnupg/mastersub.unarmored.key --output mastersub.paperkey.txt
#+end_src

Print it and then clear your printer's internal cache...
